<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ include file="..\Core.ttinclude" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2015 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

#if UNITY_STANDALONE || UNITY_WEBPLAYER || UNITY_WII || UNITY_IPHONE || UNITY_ANDROID || UNITY_PS3 || UNITY_XBOX360 || UNITY_FLASH || UNITY_BKACKBERRY || UNITY_WINRT
#define UNITY
#endif

using System;
using System.Collections.Generic;
#if !UNITY
#if CORE_CLR
using Contract = MsgPack.MPContract;
#else
using System.Diagnostics.Contracts;
#endif // CORE_CLR
#endif // !UNITY
using System.Linq;
using System.Text;

namespace MsgPack
{
	// This file was generated from Packer.Packing.tt and StreamingUnapkcerBase.ttinclude T4Template.
	// Do not modify this file. Edit Packer.Packing.tt and StreamingUnapkcerBase.ttinclude instead.

	partial class Packer
	{
<#
	// integer
for ( var bits = 16; bits < 128; bits *= 2 )
{
	foreach ( var isSigned in new [] { true, false } )
	{
		var suffix = bits.ToString( "D", CultureInfo.InvariantCulture );
		var typeName = ( isSigned ? "Int" : "UInt") + suffix;
#>
		#region -- <#= typeName #> --

		/// <summary>
		///		Packs <see cref="<#= typeName #>"/> value to current stream.
		/// </summary>
		/// <param name="value"><see cref="<#= typeName #>"/> value.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
<#
		if ( !isSigned )
		{
#>
#if !UNITY
		[CLSCompliant( false )]
#endif // !UNITY
<#
		}
#>
		public Packer Pack( <#= typeName #> value )
		{
			this.VerifyNotDisposed();
#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY
			this.PrivatePackCore( value );
			return this;
		}

		private void PrivatePackCore( <#= typeName #> value )
		{
			if ( this.TryPackTiny<#= isSigned ? "Signed" : "Unsigned" #>Integer( value ) )
			{
				return;
			}

<#
		for ( var i = 8; i < bits; i *= 2 )
		{
#>
			if ( this.TryPack<#= isSigned ? "Int" : "UInt" #><#= i.ToString( "D", CultureInfo.InvariantCulture ) #>( value ) )
			{
				return;
			}

<#
		}
#>
#pragma warning disable 168
			var b = this.TryPack<#= isSigned ? "Int" : "UInt" #><#= suffix #>( value );
#pragma warning restore 168
#if !UNITY && DEBUG
			Contract.Assert( b, "success" );
#endif // !UNITY && DEBUG
		}

		/// <summary>
		///		Try packs <see cref="<#= typeName #>"/> value to current stream strictly.
		/// </summary>
		/// <param name="value">Maybe <see cref="<#= typeName #>"/> value.</param>
		/// <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
<#
		if ( !isSigned )
		{
#>
#if !UNITY
		[CLSCompliant( false )]
#endif // !UNITY
<#
		}
#>
		protected bool TryPack<#= typeName #>( <#= isSigned ? "Int" : "UInt" #>64 value )
		{
<#
		if ( bits < 64 )
		{
			if ( isSigned )
			{
#>
			if ( value < <#= typeName #>.MinValue || value > <#= typeName #>.MaxValue )
<#
			}
			else
			{
#>
			if ( value > <#= typeName #>.MaxValue )
<#
			}
#>
			{
				return false;
			}
<#
		}
#>

			this.WriteByte( MessagePackCode.<#= isSigned ? "Signed" : "Unsigned" #>Int<#= suffix #> );
			unchecked
			{
<#
			WritePackBytes( bits, "value", 4 );
#>
			}
			return true;
		}

		#endregion -- <#= typeName #> --

<#
	}
}
// End integer

// Real
#>
		#region -- Single --

		/// <summary>
		///		Packs <see cref="Single"/> value to current stream.
		/// </summary>
		/// <param name="value"><see cref="Single"/> value.</param>
		/// <returns>This instance.</returns>
		public Packer Pack( float value )
		{
			this.VerifyNotDisposed();
			this.PrivatePackCore( value );
			return this;
		}

		private void PrivatePackCore( float value )
		{
			this.WriteByte( MessagePackCode.Real32 );

			var bits = new Float32Bits( value );

			if ( BitConverter.IsLittleEndian )
			{
<#
			WritePackFloat32Bytes( Enumerable.Range( 0, 4 ).Reverse(), "bits.Byte", 4 );
#>
			}
			else
			{
<#
			WritePackFloat32Bytes( Enumerable.Range( 0, 4 ), "bits.Byte", 4 );
#>
			}
		}

		#endregion -- Single --

		#region -- Double --

		/// <summary>
		///		Packs <see cref="Double"/> value to current stream.
		/// </summary>
		/// <param name="value"><see cref="Double"/> value.</param>
		/// <returns>This instance.</returns>
		public Packer Pack( double value )
		{
			this.VerifyNotDisposed();
			this.PrivatePackCore( value );
			return this;
		}

		private void PrivatePackCore( double value )
		{
			this.WriteByte( MessagePackCode.Real64 );
			unchecked
			{
				long bits = BitConverter.DoubleToInt64Bits( value );
<#
			WritePackBytes( 64, "bits", 4 );
#>
			}
		}

		#endregion -- Double --

		#region -- Collection Header --

<#
// End Real

// Array/Map
foreach ( var item in 
	new [] 
	{ 
		new { Type = "Array", Label = "Array length or list items count" },
		new { Type = "Map", Label = "Dictionary (map) items count" },
	}
)
{
#>
		/// <summary>
		///		Bookkeep <#= item.Label.ToLowerInvariant() #> to be packed on current stream.
		/// </summary>
		/// <param name="count"><#= item.Label #>.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		public Packer Pack<#= item.Type #>Header( int count )
		{
			this.Pack<#= item.Type #>HeaderCore( count );
			return this;
		}

		/// <summary>
		///		Bookkeep <#= item.Label.ToLowerInvariant() #> to be packed on current stream.
		/// </summary>
		/// <param name="count"><#= item.Label #>.</param>
		/// <returns>This instance.</returns>
		protected void Pack<#= item.Type #>HeaderCore( int count )
		{
			if ( count < 0 )
			{
				ThrowCannotBeNegativeException( "count" );
			}

#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY
			this.VerifyNotDisposed();

			this.PrivatePack<#= item.Type #>HeaderCore( count );
		}

		private void PrivatePack<#= item.Type #>HeaderCore( int count )
		{
#if !UNITY
			Contract.Assert( 0 <= count, "0 <= count" );
#endif // !UNITY
			if ( count < 16 )
			{
				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixed<#= item.Type #> | count ) ) );
			}
			else if ( count <= UInt16.MaxValue )
			{
				this.WriteByte( MessagePackCode.<#= item.Type #>16 );
				unchecked
				{
<#
	WritePackBytes( 16, "count", 5 );
#>
				}
			}
			else
			{
				this.WriteByte( MessagePackCode.<#= item.Type #>32 );
				unchecked
				{
<#
	WritePackBytes( 32, "count", 5 );
#>
				}
			}
		}

<#
}
// End Array/Map

// String/Binary header

var stringBinaryItems =
	new [] 
	{ 
		new { Type = "Raw",		SummarySuffix = "as the bytes might represent well formed encoded string.",			ParamDescription = "A length of byte array." },
		new { Type = "String",	SummarySuffix = "as the bytes should represent well formed encoded string.",		ParamDescription = "A length of encoded byte array." },
		new { Type = "Binary",	SummarySuffix = "as the bytes should not represent well formed encoded string.",	ParamDescription = "A length of byte array." },
	};

foreach ( var item in stringBinaryItems )
{
#>
		/// <summary>
		///		Bookkeep byte length to be packed on current stream <#= item.SummarySuffix #>
		/// </summary>
		/// <param name="length"><#= item.ParamDescription #></param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
<#
	if ( item.Type == "Raw" )
	{
#>
		/// <remarks>
		///		This method effectively acts as alias of <see cref="PackStringHeader"/> for compatibility.
		/// </remarks>
		[Obsolete( "Use PackStringHeader(Int32) or Use PackBinaryHeader(Int32) instead." )]
<#
	}
#>
		public Packer Pack<#= item.Type #>Header( int length )
		{
			this.Pack<#= item.Type #>HeaderCore( length );
			return this;
		}

<#
}
// String/Binary header

// String/Binary header core
foreach ( var item in stringBinaryItems )
{
#>
		/// <summary>
		///		Bookkeep byte length to be packed on current stream <#= item.SummarySuffix #>
		/// </summary>
		/// <param name="length"><#= item.ParamDescription #></param>
<#
	if ( item.Type == "Raw" )
	{
#>
		/// <remarks>
		///		This method acts as alias of <see cref="PackStringHeaderCore"/> for compatibility.
		/// </remarks>
		[Obsolete( "Use PackStringHeaderCore(Int32) or Use PackBinaryHeaderCore(Int32) instead." )]
		protected void PackRawHeaderCore( int length )
		{
			this.PackStringHeaderCore( length );
		}

<#
	}
	else
	{
#>
		protected void Pack<#= item.Type #>HeaderCore( int length )
		{
			if ( length < 0 )
			{
				ThrowCannotBeNegativeException( "length" );
			}

#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY
			this.VerifyNotDisposed();

			this.PrivatePackRawHeaderCore( length, <#= ( item.Type == "String" ).ToString().ToLowerInvariant() #> );
		}

<#
	}
}
// End String/Binary header core
#>
		private void PrivatePackRawHeaderCore( int length, bool isString )
		{
#if !UNITY
			Contract.Assert( 0 <= length, "0 <= length" );
#endif // !UNITY

			if ( isString || ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 )
			{
				if ( length < 32 )
				{
					this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) ) );
					return;
				}

<#
WritePackBinary( isString: true );
#>
			}
			else
			{
				// !isString && compat options is not set.

<#
WritePackBinary( isString: false );
#>
			}
		}

		#endregion -- Collection Header --

<#
foreach ( var item in 
	new []
	{
		new { Type = "Raw",		TypeNote = "it may or may not be string",	Remarks = "This method use str types (previously known as raw types) for compability." },
		new { Type = "Binary",	TypeNote = "it should not be string",		Remarks = "This method use bin types unless <see cref=\"CompatibilityOptions\"/> contains <see cref=\"PackerCompatibilityOptions.PackBinaryAsRaw\"/>." },
	}
)
{
#>
		#region -- <#= item.Type #> with Header --

<#
	foreach ( var parameter in
		new []
		{
			new { Type = "IEnumerable<byte>",	AsType = "ICollection<byte>",	AsName = "asCollection",	Label = "byte sequence",	Description = "Source bytes its size is not known." },
			new { Type = "IList<byte>",			AsType = "byte[]",				AsName = "asByteArray",		Label = "byte collection",	Description = "Source bytes its size is known." },
			new { Type = "byte[]",				AsType = default( string ),		AsName = default( string ),	Label = "byte array",		Description = "A byte array." }
		}
	)
	{
#>
		/// <summary>
		///		Packs specified <#= parameter.Label #>(<#= item.TypeNote #> to current stream.
		/// </summary>
		/// <param name="value"><#= parameter.Description #></param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		/// <remarks>
		///		<#= item.Remarks #>
		/// </remarks>
		public Packer Pack<#= item.Type #>( <#= parameter.Type #> value )
		{
			this.VerifyNotDisposed();
#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY

<#
		if ( parameter.AsType != null )
		{
#>
			var <#= parameter.AsName #> = value as <#= parameter.AsType #>;
			if ( <#= parameter.AsName #> == null )
			{
				this.PrivatePack<#= item.Type #>( value );
			}
			else
			{
				this.PrivatePack<#= item.Type #>( <#= parameter.AsName #> );
			}

<#
		}
		else
		{
#>
			this.PrivatePack<#= item.Type #>( value );
<#
		}
#>
			return this;
		}

<#
	}
#>
		private void PrivatePack<#= item.Type #>( ICollection<byte> value )
		{
			if ( value == null )
			{
				this.PrivatePackNullCore();
				return;
			}

			this.PrivatePackRawHeaderCore( value.Count, /*isString:*/ <#= ( item.Type == "Raw" ).ToString().ToLowerInvariant() #> );
			this.WriteBytes( value );
		}

<#
	foreach ( var type in 
		new [] 
		{ 
			new { Name = "byte[]",				ExtraArguments = ", false" },
			new { Name = "IEnumerable<byte>",	ExtraArguments = String.Empty }
		}
	)
	{
#>
		private void PrivatePack<#= item.Type #>( <#= type.Name #> value )
		{
			if ( value == null )
			{
				this.PrivatePackNullCore();
				return;
			}

			this.PrivatePack<#= item.Type #>Core( value<#= type.ExtraArguments #> );
		}

<#
	}
#>
		private void PrivatePack<#= item.Type #>Core( byte[] value, bool isImmutable )
		{
			this.PrivatePackRawHeaderCore( value.Length, /*isString:*/ <#= ( item.Type == "Raw" ).ToString().ToLowerInvariant() #> );
			this.WriteBytes( value, isImmutable );
		}

		private void PrivatePack<#= item.Type #>Core( IEnumerable<byte> value )
		{
			if ( !this.CanSeek )
			{
				// buffered
				this.PrivatePack<#= item.Type #>Core( value.ToArray(), true );
			}
			else
			{
				// Header
<#
	if ( item.Type == "Raw" )
	{
#>
				this.WriteByte( MessagePackCode.Raw32 );
<#
	}
	else
	{
#>
				// Use biggest data size because actual binary length is not known.
				if ( ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 )
				{
					this.WriteByte( MessagePackCode.Raw32 );
				}
				else
				{
					this.WriteByte( MessagePackCode.Bin32 );
				}

<#
	}
#>
				this.StreamWrite( value, ( items, _ ) => this.PrivatePackRawBodyCore( items ), null );
			}
		}

		#endregion -- <#= item.Type #> with Header --

<#
}
#>
		#region -- String with Header  --

<#
var stringItems =
	new []
	{
		new { Type = "IEnumerable<char>",	ParamLabel = "charactor sequence",	ParamDescription = "Source chars its size is not known." },
		new { Type = "string",				ParamLabel = "string",				ParamDescription = "Source string." },
	};

// String
foreach ( var item in stringItems )
{
	foreach ( var withEncoding in new [] { false, true } )
	{
#>
		/// <summary>
		///		Packs specified <#= item.ParamLabel #> to current stream with <#= withEncoding ? "specified" : "UTF-8" #> <see cref="Encoding"/>.
		/// </summary>
		/// <param name="value"><#= item.ParamDescription #></param>
<#
		if ( withEncoding )
		{
#>
		/// <param name="encoding"><see cref="Encoding"/> to be used.</param>
<#
		}
#>
		/// <returns>This instance.</returns>
<#
		if ( withEncoding )
		{
#>
		/// <exception cref="ArgumentNullException"><paramref name="encoding" /> is <c>null</c>.</exception>
<#
		}
#>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		public Packer PackString( <#= item.Type #> value<#= withEncoding ? ", Encoding encoding" : String.Empty #> )
		{
			this.PackStringCore( value, <#= withEncoding ? "encoding" : "Encoding.UTF8" #> );
			return this;
		}

<#
	}

#>
		/// <summary>
		///		Packs specified <#= item.ParamLabel #> to current stream with specified <see cref="Encoding"/>.
		/// </summary>
		/// <param name="value"><#= item.ParamDescription #></param>
		/// <param name="encoding"><see cref="Encoding"/> to be used.</param>
		/// <exception cref="ArgumentNullException"><paramref name="encoding" /> is <c>null</c>.</exception>
		protected virtual void PackStringCore( <#= item.Type #> value, Encoding encoding )
		{
			if ( encoding == null )
			{
				ThrowArgumentNullException( "encoding ");
			}

#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY
			this.VerifyNotDisposed();

			this.PrivatePackString( value, encoding );
		}

		private void PrivatePackString( <#= item.Type #> value, Encoding encoding )
		{
#if !UNITY
			Contract.Assert( encoding != null, "encoding != null" );
#endif // !UNITY

			if ( value == null )
			{
				this.PrivatePackNullCore();
				return;
			}

			this.PrivatePackStringCore( value, encoding );
		}

		private void PrivatePackStringCore( <#= item.Type #> value, Encoding encoding )
		{
#if !UNITY
			Contract.Assert( value != null, "value != null" );
			Contract.Assert( encoding != null, "encoding != null" );
#endif // !UNITY

			// TODO: streaming encoding
			var encoded = encoding.GetBytes( value<#= item.Type != "string" ? ".ToArray()" : String.Empty #> );
			this.PrivatePackRawHeaderCore( encoded.Length, /*isString:*/ true );
			this.WriteBytes( encoded, true );
		}

<#
}
#>
		#endregion -- String with Header  --

		#region -- Raw Body --

		/// <summary>
		///		Packs specified byte array to current stream without any header.
		/// </summary>
		/// <param name="value">Source byte array.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		/// <remarks>
		///		If you forget to write header first, then resulting stream will be corrupsed.
		/// </remarks>
		public Packer PackRawBody( byte[] value )
		{
			if ( value == null )
			{
				throw new ArgumentNullException( "value" );
			}

			this.VerifyNotDisposed();
#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY

			this.WriteBytes( value, false );
			return this;
		}

		/// <summary>
		///		Packs specified byte sequence to current stream without any header.
		/// </summary>
		/// <param name="value">Source byte array.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		/// <remarks>
		///		If you forget to write header first, then resulting stream will be corrupsed.
		/// </remarks>
		public Packer PackRawBody( IEnumerable<byte> value )
		{
			if ( value == null )
			{
				throw new ArgumentNullException( "value" );
			}

			this.VerifyNotDisposed();
#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY

			this.PrivatePackRawBodyCore( value );
			return this;
		}

		private int PrivatePackRawBodyCore( IEnumerable<byte> value )
		{
#if !UNITY
			Contract.Assert( value != null, "value != null" );
#endif // !UNITY

			var asCollection = value as ICollection<byte>;
			if ( asCollection != null )
			{
				return this.PrivatePackRawBodyCore( asCollection, asCollection.IsReadOnly );
			}

			int bodyLength = 0;

			foreach ( var b in value )
			{
				this.WriteByte( b );
				bodyLength++;
			}

			return bodyLength;
		}

		private int PrivatePackRawBodyCore( ICollection<byte> value, bool isImmutable )
		{
#if !UNITY
			Contract.Assert( value != null, "value != null" );
#endif // !UNITY

			var asArray = value as byte[];
			if ( asArray != null )
			{
				this.WriteBytes( asArray, isImmutable );
			}
			else
			{
				this.WriteBytes( value );
			}

			return value.Count;
		}

		#endregion -- Raw Body --
	
		#region -- IList --

		/// <summary>
		///		Bookkeep collection count to be packed on current stream.
		/// </summary>
		/// <param name="array">Collection count to be written.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		public Packer PackArrayHeader<TItem>( IList<TItem> array )
		{
			return array == null ? this.PackNull() : this.PackArrayHeader( array.Count );
		}

		#endregion -- IList --

		#region -- IDictionary --

		/// <summary>
		///		Bookkeep dictionary count to be packed on current stream.
		/// </summary>
		/// <param name="map">Dictionary count to be written.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		public Packer PackMapHeader<TKey, TValue>( IDictionary<TKey, TValue> map )
		{
			return map == null ? this.PackNull() : this.PackMapHeader( map.Count );
		}

		#endregion -- IDictionary --

		#region -- Ext --

		/// <summary>
		/// Packs an extended type value.
		/// </summary>
		/// <param name="typeCode">A type code of the extended type value.</param>
		/// <param name="body">A binary value portion of the extended type value.</param>
		/// <returns>This instance. </returns>
		/// <exception cref="ArgumentNullException"><paramref name="body"/> is <c>null</c>.</exception>
		/// <exception cref="InvalidOperationException"><see cref="CompatibilityOptions"/> property contains <see cref="PackerCompatibilityOptions.ProhibitExtendedTypeObjects"/>.</exception>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		public Packer PackExtendedTypeValue( byte typeCode, byte[] body )
		{
			if ( body == null )
			{
				throw new ArgumentNullException( "body" );
			}

			this.VerifyNotDisposed();
#if !UNITY
			Contract.EndContractBlock();
#endif // !UNITY

			this.PrivatePackExtendedTypeValueCore( typeCode, body );
			return this;
		}

		/// <summary>
		///		Packs an extended type value.
		/// </summary>
		/// <param name="mpeto">A <see cref="MessagePackExtendedTypeObject"/> to be packed.</param>
		/// <returns>This instance.</returns>
		/// <exception cref="ArgumentException"><see cref="MessagePackExtendedTypeObject.IsValid"/> of <paramref name="mpeto"/> is <c>false</c>.</exception>
		/// <exception cref="InvalidOperationException"><see cref="CompatibilityOptions"/> property contains <see cref="PackerCompatibilityOptions.ProhibitExtendedTypeObjects"/>.</exception>
		/// <exception cref="ObjectDisposedException">This instance has been disposed.</exception>
		public Packer PackExtendedTypeValue( MessagePackExtendedTypeObject mpeto )
		{
			if ( !mpeto.IsValid )
			{
				throw new ArgumentException( "MessagePackExtendedTypeObject must have body.", "mpeto" );
			}

			this.PrivatePackExtendedTypeValueCore( mpeto.TypeCode, mpeto.Body );
			return this;
		}

		private void PrivatePackExtendedTypeValueCore( byte typeCode, byte[] body )
		{
			if ( ( this._compatibilityOptions & PackerCompatibilityOptions.ProhibitExtendedTypeObjects ) != 0 )
			{
				throw new InvalidOperationException( "ExtendedTypeObject is prohibited in this packer." );
			}

			switch ( body.Length )
			{
<#
for( var i = 1; i < 32; i *= 2 )
{
#>
				case <#= i #>:
				{
					this.WriteByte( MessagePackCode.FixExt<#= i #> );
					break;
				}
<#
}
#>
				default:
				{
					unchecked
					{
						if ( body.Length < 0x100 )
						{
							this.WriteByte( MessagePackCode.Ext8 );
<#
WritePackBytes( 8, "body.Length", 7 );
#>
						}
						else if ( body.Length < 0x10000 )
						{
							this.WriteByte( MessagePackCode.Ext16 );
<#
WritePackBytes( 16, "body.Length", 7 );
#>
						}
						else
						{
							this.WriteByte( MessagePackCode.Ext32 );
<#
WritePackBytes( 32, "body.Length", 7 );
#>
						}
					}

					break;
				}
			} // switch

			this.WriteByte( typeCode );
			this.WriteBytes( body, true );
		}

		#endregion -- Ext --

		private void StreamWrite<TItem>( IEnumerable<TItem> value, Action<IEnumerable<TItem>, PackingOptions> writeBody, PackingOptions options )
		{
			if ( this.CanSeek )
			{
				// Reserve length
				this.SeekTo( 4L );
				var headerPosition = this.Position;
				// Write body
				writeBody( value, options );
				var bodyLength = this.Position - headerPosition;
				// Back to reserved length
				this.SeekTo( -bodyLength );
				this.SeekTo( -4L );
				unchecked
				{
<#
WritePackBytes( 32, "bodyLength", 5 );
#>
				}
				// Forward to body tail
				this.SeekTo( bodyLength );
			}
			else
			{
				// Copying is better than forcing stream is seekable...
				var asCollection = value as ICollection<TItem> ?? value.ToArray();

				var bodyLength = asCollection.Count;
				unchecked
				{
<#
WritePackBytes( 32, "bodyLength", 5 );
#>
				}

				writeBody( asCollection, options );
			}
		}
	}
}
<#+
void WritePackBytes( int bits, string expression, int indentLevel )
{
	for ( var i = bits - 8; i > 0; i -= 8 )
	{
#>
<#= new String( Enumerable.Repeat( '\t', indentLevel ).ToArray() ) #>this.WriteByte( ( byte )( ( <#= expression #> >> <#= i.ToString( "D", CultureInfo.InvariantCulture ) #> ) & 0xFF ) );
<#+
	}
#>
<#= new String( Enumerable.Repeat( '\t', indentLevel ).ToArray() ) #>this.WriteByte( ( byte )( <#= expression #> & 0xFF ) );
<#+
}

void WritePackFloat32Bytes( IEnumerable<int> suffixes, string expression, int indentLevel )
{
	foreach ( var suffix in suffixes )
	{
#>
<#= new String( Enumerable.Repeat( '\t', indentLevel ).ToArray() ) #>this.WriteByte( <#= expression #><#= suffix.ToString( "D", CultureInfo.InvariantCulture ) #> );
<#+
	}
}

void WritePackBinary( bool isString )
{
	var prefix = isString ? "Str" : "Bin";
#>
				if ( length <= Byte.MaxValue<#= isString ? " && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0" : String.Empty #> )
				{
					this.WriteByte( MessagePackCode.<#= prefix #>8 );
					unchecked
					{
<#+
	WritePackBytes( 8, "length", 6 );
#>
					}
				}
				else if ( length <= UInt16.MaxValue )
				{
					this.WriteByte( MessagePackCode.<#= prefix #>16 );
					unchecked
					{
<#+
	WritePackBytes( 16, "length", 6 );
#>
					}
				}
				else
				{
					this.WriteByte( MessagePackCode.<#= prefix #>32 );
					unchecked
					{
<#+
	WritePackBytes( 32, "length", 6 );
#>
					}
				}
<#+
}
#>