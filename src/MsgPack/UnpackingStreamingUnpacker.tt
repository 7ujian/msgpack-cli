<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file=".\StreamingUnpackerBase.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2012 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

namespace MsgPack
{
<#
PushIndent( 1 );
WriteUnpacker();
PopIndent();
#>
<#+

// ---- MACROS ----

private string TypeName
{
	get { return "UnpackingStreamingUnpacker"; }
}

private string IsInScalarUnpackingExpression
{
	get { return "this._scalarBufferPosition >= 0"; }
}

private string IsInBlobUnpackingExpression
{
	get { return "this._blobBuffer != null"; }
}

private void OnUnpacking()
{
#>
this._collectionItemsCount = null;
<#+
}

private void OnReadNextByte( string sourceExpression, string valueExpression )
{
#>
var <#= valueExpression #> = <#= sourceExpression #>.ReadByte();
if(  <#= valueExpression #> >= 0 )
<#+
}

private void OnStartUnpackingScalar( string kindExpression, CollectionKind collectionKind, int bits )
{
#>

#region StartScalarUnpacking
this._collectionHeaderKind = CollectionHeaderKind.<#= collectionKind #>;
this._scalarKind = <#= kindExpression #>;
this._scalarBufferPosition = 0;
<#+
	if( collectionKind != CollectionKind.NotCollection )
	{
		WritePushContextCollection( collectionKind );
	}

	this.WriteUnpackScalarCore( kindExpression, collectionKind, bits, "0", "( ( int )" + kindExpression + " ) & 0xF" );
#>
#endregion StartScalarUnpacking

<#+
}

private void OnContinueUnpackingScalar()
{
#>

#region ContinueScalarUnpacking
<#+
	WriteClearEmptyCollectionState( null );
	WriteUnpackScalarCore( "this._scalarKind", CollectionKind.NotCollection, 0, "this._scalarBufferPosition", "( ( ( int )this._scalarKind ) & 0xF ) - this._scalarBufferPosition" );
#>
#endregion ContinueScalarUnpacking

<#+
}

private void WriteUnpackScalarCore( string kindExpression, CollectionKind collectionKind, int bits, string offsetExpression, string lengthExpression )
{
#>
var scalarReadBytes = source.Read( this._scalarBuffer, <#= offsetExpression #>, <#= lengthExpression #> );
if( scalarReadBytes < ( <#= lengthExpression #> ) )
{
	// Must wait extra bytes, book keep states.
	this._scalarBufferPosition += scalarReadBytes;
	return null;
}
else
{
	// Whole scalar bytes are read.
<#+
	switch( collectionKind )
	{
		case CollectionKind.Array:
		case CollectionKind.Map:
		{
			PushIndent( 1 );
			WriteHandleCollectionLength( collectionKind, bits );
			PopIndent();
			break;
		}
		default:
		{
#>
	switch( this._scalarKind )
	{
		case ScalarKind.RawLength16:
		{
<#+
			PushIndent( 3 );
			WriteSwapScalarBufferIfLittleEndian( 2 ); 
			PopIndent();
#>
			ushort length = BitConverter.ToUInt16( this._scalarBuffer, 0 );
<#+
			PushIndent( 3 );
			OnStartUnpackingBlob( "length" ); 
			PopIndent();
#>
		}
		case ScalarKind.RawLength32:
		{
<#+
			PushIndent( 3 );
			WriteSwapScalarBufferIfLittleEndian( 4 );
			PopIndent();
#>
			uint length = BitConverter.ToUInt32( this._scalarBuffer, 0 );
<#+
			PushIndent( 3 );
			WriteEnsureLengthIsInt32( "length" );
			OnStartUnpackingBlob( "unchecked( ( int )length )" ); 
			PopIndent();
#>
		}
		case ScalarKind.ArrayLength16:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Array, 16 );
			PopIndent();
#>
		}
		case ScalarKind.MapLength16:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Map, 16 );
			PopIndent();
#>
		}
		case ScalarKind.ArrayLength32:
		{
<#+
	PushIndent( 3 );
	WriteHandleCollectionLength( CollectionKind.Array, 32 );
	PopIndent();
#>
		}
		case ScalarKind.MapLength32:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Map, 32 );
			PopIndent();
#>
		}
		case ScalarKind.Float32:
		{
<#+
			PushIndent( 3 );
			WriteSwapScalarBufferIfLittleEndian( 4 );
			PopIndent();
#>
			var value = BitConverter.ToSingle( this._scalarBuffer, 0 );
<#+
			PushIndent( 3 );
			WriteClearScalarBuffer(); 
			WriteTryPopContextCollection( null );
			PopIndent();
#>
			return new MessagePackObject( value );
		}
		case ScalarKind.Float64:
		{
<#+
			PushIndent( 3 );
			WriteSwapScalarBufferIfLittleEndian( 8 );
			PopIndent();
 #>
			var value = BitConverter.ToDouble( this._scalarBuffer, 0 );
<#+
			PushIndent( 3 );
			WriteClearScalarBuffer();
			WriteTryPopContextCollection( null );
			PopIndent();
#>
			return new MessagePackObject( value );
		}
		case ScalarKind.Int8:
		{
			var value = unchecked( ( sbyte )this._scalarBuffer[ 0 ] );
<#+
			PushIndent( 3 );
			WriteClearScalarBuffer();
			WriteTryPopContextCollection( null );
			PopIndent();
#>
			return new MessagePackObject( value );
		}
		case ScalarKind.UInt8:
		{
			var value = this._scalarBuffer[ 0 ];
<#+
			PushIndent( 3 );
			WriteClearScalarBuffer();
			WriteTryPopContextCollection( null );
			PopIndent();
#>
			return new MessagePackObject( value );
		}
<#+
			foreach( var integerBits in new [] { 16, 32, 64 } )
			{
#>
		case ScalarKind.Int<#= integerBits.ToString( CultureInfo.InvariantCulture ) #>:
		{
<#+
				PushIndent( 3 );
				WriteSwapScalarBufferIfLittleEndian( integerBits / 8 );
				PopIndent();
#>
			var value = BitConverter.ToInt<#= integerBits.ToString( CultureInfo.InvariantCulture ) #>( this._scalarBuffer, 0 );
<#+
				PushIndent( 3 );
				WriteClearScalarBuffer();
				WriteTryPopContextCollection( null );
				PopIndent();
#>
			return new MessagePackObject( value );
		}
		case ScalarKind.UInt<#= integerBits.ToString( CultureInfo.InvariantCulture ) #>:
		{
<#+
				PushIndent( 3 );
				WriteSwapScalarBufferIfLittleEndian( integerBits / 8 );
				PopIndent();
#>
			var value = BitConverter.ToUInt<#= integerBits.ToString( CultureInfo.InvariantCulture ) #>( this._scalarBuffer, 0 );
<#+
				PushIndent( 3 );
				WriteClearScalarBuffer();
				WriteTryPopContextCollection( null );
				PopIndent();
#>
			return new MessagePackObject( value );
		}
<#+
			}
#>
		default:
		{
			throw new NotSupportedException( String.Format( CultureInfo.CurrentCulture, "Unknown scalar '{0}'.", this._scalarKind ) );
		}
	} // switch <#= kindExpression #> 
<#+
			break;
		}
	}
#>
}
<#+
}

private void WriteHandleCollectionLength( CollectionKind kind, int bits )
{
WriteSwapScalarBufferIfLittleEndian( bits / 8 );
#>
var length = BitConverter.ToUInt<#= bits.ToString( CultureInfo.InvariantCulture ) #>( this._scalarBuffer, 0 );
<#+
WriteClearScalarBuffer();
WriteTryPopContextCollection( null );
#>
this._currentCollectionState.SetItemsCount( length );
return new MessagePackObject( length );
<#+
}

private void WriteClearScalarBuffer()
{
#>

#region ClearScalarBuffer
this._scalarBufferPosition = -1;
#endregion ClearScalarBuffer

<#+
}

private void WriteSwapScalarBufferIfLittleEndian( int size )
{
#>

#region SwapScalarBufferIfLittleEndian
if( BitConverter.IsLittleEndian )
{
	byte temp;
<#+
	for( int i = 0; i < size / 2; i++ )
	{
#>
	temp = this._scalarBuffer[ <#= i #> ];
	this._scalarBuffer[ <#= i #> ] = this._scalarBuffer[ <#= size - i - 1 #> ];
	this._scalarBuffer[ <#= size - i - 1 #> ] = temp;
<#+ 
	}
#>
}
#endregion SwapScalarBufferIfLittleEndian

<#+
}

private void OnStartUnpackingBlob( string lengthExpression )
{
#>

#region StartBlobUnpacking
<#+
	WriteClearScalarBuffer();
#>
this._collectionHeaderKind = CollectionHeaderKind.NotCollection;
var blob = new byte[ <#= lengthExpression #> ];
<#+
	WriteUnpackBlobCore( "0", lengthExpression );
#>
#endregion StartBlobUnpacking

<#+
}

private void OnContinueUnpackingBlob()
{
#>

#region ContinueBlobUnpacking
var blob = this._blobBuffer;
<#+
	WriteClearEmptyCollectionState( null );
	WriteUnpackBlobCore( "this._blobBufferPosition", "this._blobBuffer.Length - this._blobBufferPosition" );
#>
#endregion ContinueBlobUnpacking

<#+
}

private void WriteUnpackBlobCore( string offsetExpression, string lengthExpression )
{
#>
var blobReadBytes = source.Read( blob, <#= offsetExpression #>, <#= lengthExpression #> );

if( blobReadBytes < <#= lengthExpression #> )
{
	// Must wait extra bytes, book keep states.
	this._blobBuffer = blob;
	this._blobBufferPosition += blobReadBytes;

	return null;
}
else
{
	// Whole blob bytes are read.
	// Reset buffer.
	this._blobBuffer = null;
	this._blobBufferPosition = 0;

<#+
	PushIndent( 1 );
	WriteTryPopContextCollection( null );
	PopIndent();
#>
	return new MessagePackObject( blob );
}
<#+
}

private void OnUnpackedEmptyCollectionHeader( CollectionKind type )
{
#>
this._collectionHeaderKind = CollectionHeaderKind.<#= type #>;
<#+
	WriteTryPopContextCollection( null );
#>
this._collectionItemsCount = 0;
return _positiveIntegers[ 0 ];
<#+
}

private void OnUnpackedPositiveTinyInteger( string value )
{
#>
this._collectionHeaderKind = CollectionHeaderKind.NotCollection;
<#+
	WriteTryPopContextCollection( null );
#>
return _positiveIntegers[ <#= value #> ];
<#+
}

private void OnUnpackedNegativeTinyInteger( string value )
{
#>
this._collectionHeaderKind = CollectionHeaderKind.NotCollection;
<#+
	WriteTryPopContextCollection( null );
#>
return _negativeIntegers[ <#= value #> - 0xE0 ];
<#+
}

private void OnUnpackedEmptyRawHeader()
{
#>
this._collectionHeaderKind = CollectionHeaderKind.NotCollection;
<#+
	WriteTryPopContextCollection( null );
#>
return _emptyRaw;
<#+
}

private void OnUnpackedConstantValue( ConstantValue value )
{
#>
this._collectionHeaderKind = CollectionHeaderKind.NotCollection;
<#+
	WriteTryPopContextCollection( null );

	switch( value )
	{
		case ConstantValue.Nil:
		{
#>
return MessagePackObject.Nil;
<#+
			break;
		}
		case ConstantValue.True:
		{
#>
return _true;
<#+
			break;
		}
		case ConstantValue.False:
		{
#>
return _false;
<#+
			break;
		}
	}
}

private void OnUnpackedTinyCollectionLength( string lengthExpression, CollectionKind kind )
{
#>
this._collectionHeaderKind = CollectionHeaderKind.<#= kind #>;
<#+
	WritePushFixedContextCollection( kind, lengthExpression );
#>
return _positiveIntegers[ <#= lengthExpression #> ];
<#+
}

private void OnReadByteFromStream( string valueExpression )
{
	// nop
}
#>