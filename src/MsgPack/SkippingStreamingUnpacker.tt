<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file=".\StreamingUnpackerBase.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2012 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MsgPack
{
<#
PushIndent( 1 );
WriteUnpacker();
PopIndent();
#>
<#+

// ---- MACROS ----

private string TypeName
{
	get { return "SkippingStreamingUnpacker"; }
}

private string IsInScalarUnpackingExpression
{
	get { return "this._scalarBufferPosition >= 0"; }
}

private string IsInBlobUnpackingExpression
{
	get { return "this._remainingBlob >= 0"; }
}

private void OnUnpacking()
{
}

private void OnReadNextByte( string sourceExpression, string valueExpression )
{
#>
for( var <#= valueExpression #> = <#= sourceExpression #>.ReadByte(); <#= valueExpression #> >= 0; <#= valueExpression #> = <#= sourceExpression #>.ReadByte() )
<#+
}

private void OnStartUnpackingScalar( string kindExpression, CollectionKind collectionKind, int bits )
{
#>

#region StartScalarUnpacking
this._scalarKind = <#= kindExpression #>;
this._scalarBufferPosition = 0;
<#+
	if( collectionKind != CollectionKind.NotCollection )
	{
		WritePushContextCollection( collectionKind );
	}

	WriteUnpackScalarCore( kindExpression, collectionKind, bits, "0", "( ( int )" + kindExpression + " ) & 0xF" );
#>
#endregion StartScalarUnpacking

break;
<#+
}

private void OnContinueUnpackingScalar()
{
	WriteClearEmptyCollectionState( null );
#>

#region ContinueScalarUnpacking
<#+ WriteUnpackScalarCore( "this._scalarKind", CollectionKind.NotCollection, 0, "this._scalarBufferPosition", "( ( ( int )this._scalarKind ) & 0xF ) - this._scalarBufferPosition" ); #>
#endregion ContinueScalarUnpacking

<#+
}

private void WriteUnpackScalarCore( string kindExpression, CollectionKind collectionKind, int bits, string offsetExpression, string lengthExpression )
{
#>
var scalarReadBytes = source.Read( this._scalarBuffer, <#= offsetExpression #>, <#= lengthExpression #> );
this._readByteLength += scalarReadBytes;
if( scalarReadBytes < ( <#= lengthExpression #> ) )
{
	// Must wait extra bytes, book keep states.
	this._scalarBufferPosition += scalarReadBytes;
	return null;
}
else
{
	// Whole scalar bytes are read.
<#+
	WriteClearScalarBuffer();

	switch( collectionKind )
	{
		case CollectionKind.Array:
		case CollectionKind.Map:
		{
			PushIndent( 1 );
			WriteHandleCollectionLength( collectionKind, bits );
			PopIndent();
			break;
		}
		default:
		{
#>
	switch( this._scalarKind )
	{
		case ScalarKind.RawLength16:
		{
<#+
			PushIndent( 3 );
			WriteSwapScalarBufferIfLittleEndian( 2 ); 
			PopIndent();
#>
			ushort length = BitConverter.ToUInt16( this._scalarBuffer, 0 );
<#+
			PushIndent( 3 );
			OnStartUnpackingBlob( "length" ); 
			PopIndent();
#>
			break;
		}
		case ScalarKind.RawLength32:
		{
<#+
			PushIndent( 3 );
			WriteSwapScalarBufferIfLittleEndian( 4 );
			PopIndent();
#>
			uint length = BitConverter.ToUInt32( this._scalarBuffer, 0 );
<#+
			PushIndent( 3 );
			OnStartUnpackingBlob( "length" ); 
			PopIndent();
#>
			break;
		}
		case ScalarKind.ArrayLength16:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Array, 16 );
			PopIndent();
#>
			break;
		}
		case ScalarKind.MapLength16:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Map, 16 );
			PopIndent();
#>
			break;
		}
		case ScalarKind.ArrayLength32:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Array, 32 );
			PopIndent();
#>
			break;
		}
		case ScalarKind.MapLength32:
		{
<#+
			PushIndent( 3 );
			WriteHandleCollectionLength( CollectionKind.Map, 32 );
			PopIndent();
#>
			break;
		}
		case ScalarKind.Float32:
		case ScalarKind.Float64:
		case ScalarKind.Int8:
		case ScalarKind.UInt8:
<#+
			foreach( var integerBits in new [] { 16, 32, 64 } )
			{
#>
		case ScalarKind.Int<#= integerBits.ToString( CultureInfo.InvariantCulture ) #>:
		case ScalarKind.UInt<#= integerBits.ToString( CultureInfo.InvariantCulture ) #>:
<#+
			}
#>
		{
<#+
			PushIndent( 3 );
			WriteClearScalarBuffer();
			WriteReturnLengthIfRoot( WriteReturnLength );
			WriteTryPopContextCollection( () => WriteReturnLengthIfRoot( WriteReturnLength ) );
			PopIndent();
#>
			break;
		}
	} // switch <#= kindExpression #> 
<#+
			break;
		}
	}
#>
}
<#+
}

private void WriteHandleCollectionLength( CollectionKind kind, int bits )
{
	WriteSwapScalarBufferIfLittleEndian( bits / 8 );
#>
var length = BitConverter.ToUInt<#= bits.ToString( CultureInfo.InvariantCulture ) #>( this._scalarBuffer, 0 );
this._currentCollectionState.SetItemsCount( length );
<#+
	WriteReturnLengthIfEmpty( "length", () => WritePopContextCollection( WriteReturnLength ) );
}

private void WriteClearScalarBuffer()
{
#>

#region ClearScalarBuffer
this._scalarBufferPosition = -1;
#endregion ClearScalarBuffer

<#+
}

private void WriteSwapScalarBufferIfLittleEndian( int size )
{
#>

#region SwapScalarBufferIfLittleEndian
if( BitConverter.IsLittleEndian )
{
	byte temp;
<#+
	for( int i = 0; i < size / 2; i++ )
	{
#>
	temp = this._scalarBuffer[ <#= i #> ];
	this._scalarBuffer[ <#= i #> ] = this._scalarBuffer[ <#= size - i - 1 #> ];
	this._scalarBuffer[ <#= size - i - 1 #> ] = temp;
<#+ 
	}
#>
}
#endregion SwapScalarBufferIfLittleEndian

<#+
}

private void OnStartUnpackingBlob( string lengthExpression )
{
#>

#region StartBlobUnpacking
this._remainingBlob = <#= lengthExpression #>;
<#+
	this.WriteUnpackBlobCore( lengthExpression );
#>
#endregion StartBlobUnpacking

<#+
}

private void OnContinueUnpackingBlob()
{
#>

#region ContinueBlobUnpacking
<#+
	WriteClearEmptyCollectionState( null );
	this.WriteUnpackBlobCore( "this._remainingBlob" );
#>
#endregion ContinueBlobUnpacking

<#+
}

private void WriteUnpackBlobCore( string lengthExpression )
{
#>
long blobReadBytes = 0;
int recentRead;
int reading;
do
{
	reading  = _dummyBuffer.Length < <#= lengthExpression #> ? _dummyBuffer.Length : unchecked( ( int )<#= lengthExpression #> );
	recentRead = source.Read( _dummyBuffer, 0, reading );
	blobReadBytes += recentRead;
} while ( recentRead == reading && blobReadBytes < <#= lengthExpression #>);

this._readByteLength += blobReadBytes;
if( blobReadBytes < this._remainingBlob )
{
	// Must wait extra bytes, book keep states.
	this._remainingBlob -= blobReadBytes;

	return null;
}
else
{
	// Whole blob bytes are read.
	// Reset buffer.
	this._remainingBlob = -1;
<#+
	PushIndent( 1 );
	WriteTryPopContextCollection( null );
	WriteReturnLengthIfRoot( WriteReturnLength );
	PopIndent();
#>
}
<#+
}

private void OnReadByteFromStream( string valueExpression )
{
#>
this._readByteLength++;
<#+
}

private void OnUnpackedPositiveTinyInteger( string valueExpression )
{
	OnTiny();
}

private void OnUnpackedNegativeTinyInteger( string valueExpression )
{
	OnTiny();
}

private void OnUnpackedEmptyCollectionHeader( CollectionKind kind )
{
	OnTiny();
}

private void OnUnpackedEmptyRawHeader()
{
	OnTiny();
}

private void OnUnpackedConstantValue( ConstantValue kind )
{
	OnTiny();
}

private void OnUnpackedTinyCollectionLength( string lengthExpression, CollectionKind kind )
{
	WritePushFixedContextCollection( kind, lengthExpression );
}

private void OnTiny()
{
	WriteTryPopContextCollection( null );
	WriteReturnLengthIfRoot( WriteReturnLength );
#>
continue;
<#+
}

private void OnCollectionItemsFilled()
{
	WriteReturnLengthIfRoot( WriteReturnLength );
}

private void WriteReturnLengthIfEmpty( string lengthExpression, Action returnStatementWriter )
{
#>
if( <#= lengthExpression #> == 0 )
{
	if( this._collectionStates.Count == 1 )
	{
		// Top of stack must be empty which is pushed just now, so we can return tiny length safely.
<#+
	PushIndent( 2 );
	returnStatementWriter();
	PopIndent();
#>
	}
}
<#+
}

private void WriteReturnLengthIfRoot( Action returnStatementWriter )
{
#>
if( this._currentCollectionState == null )
{
<#+
	PushIndent( 1 );
	returnStatementWriter();
	PopIndent();
#>
}
<#+
}

private void WriteReturnLength()
{
#>
#region Returnlength
var readLength = this._readByteLength;
this._readByteLength = 0;
return new MessagePackObject( readLength );
#endregion ReturnLength
<#+
}
#>