<#
//
// MessagePack for CLI
//
// Copyright (C) 2010 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly Name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#
// This file defines direct integer conversion API portion of Unpackaging
var __typeName = "Unpacking";
var __integerTypes = new []
{
	typeof( byte ),
	typeof( sbyte ),
	typeof( short ), 
	typeof( ushort ),
	typeof( int ), 
	typeof( uint ), 
	typeof( long ), 
	typeof( ulong )
};
var __csharpPrimitives = new Dictionary<Type, String>
{
	{ typeof( bool ), "bool" },
	{ typeof( byte ), "byte" },
	{ typeof( sbyte ), "sbyte" },
	{ typeof( short ), "short" },
	{ typeof( ushort ), "ushort" },
	{ typeof( int ), "int" },
	{ typeof( uint ), "uint" },
	{ typeof( long ), "long" },
	{ typeof( ulong ), "ulong" },
	{ typeof( float ), "float" },
	{ typeof( double ), "double" },
	{ typeof( char ), "char" }
};
var __sourceTypes = new [] { "Stream", "byte[]" };

Func<Type,bool> __isClsCompliant = 
   type => ( type != typeof( sbyte ) && type != typeof( ushort ) && type != typeof( uint ) && type != typeof( ulong ) );

Func<Type,bool> __isUnsigned = 
   type => ( type == typeof( byte ) || type == typeof( ushort ) || type == typeof( uint ) || type == typeof( ulong ) );

var __typeCodes = new Dictionary<Type, string>
{
	{ typeof( byte ), "MessagePackCode.UnsignedInt8" },
	{ typeof( ushort ), "MessagePackCode.UnsignedInt16" },
	{ typeof( uint ), "MessagePackCode.UnsignedInt32" },
	{ typeof( ulong ), "MessagePackCode.UnsignedInt64" },
	{ typeof( sbyte ), "MessagePackCode.SignedInt8" },
	{ typeof( short ), "MessagePackCode.SignedInt16" },
	{ typeof( int ), "MessagePackCode.SignedInt32" },
	{ typeof( long ), "MessagePackCode.SignedInt64" }
};
#>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

using System;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.IO;

namespace MsgPack
{
	// This file generated from <#= __typeName #>.Intgers.tt T4Template.
	// Do not modify this file. Edit <#= __typeName #>.Intgers.tt instead.

	static partial class <#= __typeName #>
	{
<#
foreach( var __sourceType in __sourceTypes )
foreach( var __type in __integerTypes )
{
#>

<#
	if( __sourceType == "byte[]" )
	{
#>
		/// <summary>
		///		Unpack <see cref="<#= __type.Name #>"/> directly from start of specified <#= __sourceType #> source.
		/// </summary>
		/// <param name="source">Source <#= __sourceType #>.</param>
		/// <returns>Converted <see cref="<#= __type.Name #>"/>.</returns>
		/// <exception cref="ArgumentNullException"><paramref name="source"/> is null.</exception>
		/// <exception cref="MessageTypeException">Read value from <paramref name="source"/> is not compatible for <see cref="<#= __type.Name #>"/>.</exception>
<#
	if( !__isClsCompliant( __type ) )
	{
#>
		[CLSCompliant( false )]
<#
	}
#>
		public static UnpackArrayResult<<#= __type.Name #>> Unpack<#= __type.Name #>( <#= __sourceType #> source )
		{
			return Unpack<#= __type.Name #>( source, 0 );
		}

<#
	}

	if( __sourceType == "byte[]" )
	{
#>
		/// <summary>
		///		Unpack <see cref="<#= __type.Name #>"/> directly from specified position of specified <#= __sourceType #> source.
		/// </summary>
		/// <param name="source">Source <#= __sourceType #>.</param>
		/// <param name="offset">Offset of source binary.</param>
<#
	}
	else
	{
#>
		/// <summary>
		///		Unpack <see cref="<#= __type.Name #>"/> directly from current position of specified <#= __sourceType #> source.
		/// </summary>
		/// <param name="source">Source <#= __sourceType #>.</param>
<#
	}
#>
		/// <returns>Converted <see cref="<#= __type.Name #>"/>.</returns>
		/// <exception cref="ArgumentNullException"><paramref name="source"/> is null.</exception>
<#
	if( __sourceType == "byte[]" )
	{
#>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="offset"/> is negative.</exception>
<#
	}
#>
		/// <exception cref="MessageTypeException">Read value from <paramref name="source"/> is not compatible for <see cref="<#= __type.Name #>"/>.</exception>
<#
	if( !__isClsCompliant( __type ) )
	{
#>
		[CLSCompliant( false )]
<#
	}

	String __returnType;
	if( __sourceType == "byte[]" )
	{
		__returnType = "UnpackArrayResult<" + __type.Name + ">";
#>
		public static <#= __returnType #> Unpack<#= __type.Name #>( <#= __sourceType #> source, int offset )
<#
	}
	else
	{
		__returnType = __type.Name;
#>
		public static <#= __returnType #> Unpack<#= __type.Name #>( <#= __sourceType #> source )
<#
	}
#>
		{
			if( source == null )
			{
				throw new ArgumentNullException( "source" );
			}

<#
	switch( __sourceType )
	{
		case "byte[]":
		{
#>
			if( offset < 0 )
			{
				throw new ArgumentOutOfRangeException( "offset", String.Format( CultureInfo.CurrentCulture, "'{0}' is negative.", "offset" ) );
			}
<#
			break;
		}
		case "Stream":
		{
#>
			int readTypeCode = source.ReadByte();
			if( readTypeCode < 0 )
			{
				throw new UnpackException( "Cannot read type header." );
			}

			byte typeCode = unchecked( ( byte )readTypeCode );
<#
			break;
		}
	}
#>

			Contract.EndContractBlock();

<#
	if( !__isUnsigned( __type ) )
	{
#>
			unchecked
			{
<#
		switch( __sourceType )
		{
			case "byte[]":
			{
#>
				var resultAsInt8 = TryUnpackSByte( source, offset );
<#
				break;
			}
			case "Stream":
			{
#>
				var resultAsInt8 = TryUnpackSByte( source, typeCode );
<#
				break;
			}
		}
#>
				if ( resultAsInt8.HasValue )
				{
<#
		if( __sourceType == "byte[]" )
		{
#>
					return new <#= __returnType #>( resultAsInt8.Value.Value, resultAsInt8.Value.NewOffset );
<#
		}
		else
		{
#>
					return resultAsInt8.Value;
<#
		}
#>
				}
				else
				{
<#
		switch( __sourceType )
		{
			case "byte[]":
			{
#>
					var resultAsUInt8 = TryUnpackByte( source, offset );
<#
				break;
			}
			case "Stream":
			{
#>
					var resultAsUInt8 = TryUnpackByte( source, typeCode );
<#
				break;
			}
		}
#>
<#
		if( __type == typeof( sbyte ) )
		{
			if( __sourceType == "byte[]" )
			{
#>
					if ( resultAsUInt8.HasValue && resultAsInt8.Value.Value <= SByte.MaxValue )
					{
						return new <#= __returnType #>( ( <#= __type.Name #> )resultAsUInt8.Value.Value, resultAsUInt8.Value.NewOffset );
					}
<#
			}
			else
			{
#>
					if ( resultAsUInt8.HasValue && resultAsInt8.Value <= SByte.MaxValue )
					{
						return ( <#= __returnType #> )resultAsUInt8.Value;
					}
<#
			}
#>
				}
			}
<#
		}
		else
		{
#>
					if ( resultAsUInt8.HasValue )
					{
<#
			if( __sourceType == "byte[]" )
			{
#>
						return new <#= __returnType #>( resultAsUInt8.Value.Value, resultAsUInt8.Value.NewOffset );
<#
			}
			else
			{
#>
						return resultAsUInt8.Value;
<#
			}
#>
					}
					else
					{
<#
			switch( __sourceType )
			{
				case "byte[]":
				{
#>
						var resultAsInt16 = TryUnpackInt16( source, offset );
<#
					break;
				}
				case "Stream":
				{
#>
						var resultAsInt16 = TryUnpackInt16( source, typeCode );
<#
					break;
				}
			}
#>
						if ( resultAsInt16.HasValue )
						{
<#
			if( __sourceType == "byte[]" )
			{
#>
							return new <#= __returnType #>( resultAsInt16.Value.Value, resultAsInt16.Value.NewOffset );
<#
			}
			else
			{
#>
							return resultAsInt16.Value;
<#
			}
#>
						}
						else
						{
<#
			switch( __sourceType )
			{
				case "byte[]":
				{
#>
							var resultAsUInt16 = TryUnpackUInt16( source, offset );
<#
					break;
				}
				case "Stream":
				{
#>
							var resultAsUInt16 = TryUnpackUInt16( source, typeCode );
<#
					break;
				}
			}
#>
<#
			if( __type == typeof( short ) )
			{
				if( __sourceType == "byte[]" )
				{
#>
							if ( resultAsUInt16.HasValue && resultAsUInt16.Value.Value <= Int16.MaxValue )
							{
								return new <#= __returnType #>( ( <#= __type.Name #> )resultAsUInt16.Value.Value, resultAsUInt16.Value.NewOffset );
							}
<#
				}
				else
				{
#>
							if ( resultAsUInt16.HasValue && resultAsUInt16.Value <= Int16.MaxValue )
							{
								return ( <#= __returnType #> )resultAsUInt16.Value;
							}
<#
				}
#>
							
						}
					}
				}
			}
<#
			}
			else
			{
#>
							if ( resultAsUInt16.HasValue )
							{
<#
				if( __sourceType == "byte[]" )
				{
#>
								return new <#= __returnType #>( resultAsUInt16.Value.Value, resultAsUInt16.Value.NewOffset );
<#
				}
				else
				{
#>
								return resultAsUInt16.Value;
<#
				}
#>
							}
							else
							{
<#
				switch( __sourceType )
				{
					case "byte[]":
					{
#>
								var resultAsInt32 = TryUnpackInt32( source, offset );
<#
						break;
					}
					case "Stream":
					{
#>
								var resultAsInt32 = TryUnpackInt32( source, typeCode );
<#
						break;
					}
				}
#>
								if ( resultAsInt32.HasValue )
								{
<#
				if( __sourceType == "byte[]" )
				{
#>
									return new <#= __returnType #>( resultAsInt32.Value.Value, resultAsInt32.Value.NewOffset );
<#
				}
				else
				{
#>
									return resultAsInt32.Value;
<#
				}
#>
								}
								else
								{
<#
				switch( __sourceType )
				{
					case "byte[]":
					{
#>
									var resultAsUInt32 = TryUnpackUInt32( source, offset );
<#
						break;
					}
					case "Stream":
					{
#>
									var resultAsUInt32 = TryUnpackUInt32( source, typeCode );
<#
						break;
					}
				}
#>
<#
				if( __type == typeof( int ) )
				{
					if( __sourceType == "byte[]" )
					{
#>
									if ( resultAsUInt32.HasValue && resultAsUInt32.Value.Value <= Int32.MaxValue )
									{
										return new <#= __returnType #>( ( <#= __type.Name #> )resultAsUInt32.Value.Value, resultAsUInt32.Value.NewOffset );
									}
<#
					}
					else
					{
#>
									if ( resultAsUInt32.HasValue && resultAsUInt32.Value <= Int32.MaxValue )
									{
										return ( <#= __returnType #> )resultAsUInt32.Value;
									}
<#
					}
#>
								}
							}
						}
					}
				}
			}
<#
				}
				else
				{
#>
									if ( resultAsUInt32.HasValue )
									{
<#
				if( __sourceType == "byte[]" )
				{
#>
										return new <#= __returnType #>( resultAsUInt32.Value.Value, resultAsUInt32.Value.NewOffset );
<#
				}
				else
				{
#>
										return resultAsUInt32.Value;
<#
				}
#>
									}
									else
									{
<#
					switch( __sourceType )
					{
						case "byte[]":
						{
#>
										var resultAsInt64 = TryUnpackInt64( source, offset );
<#
							break;
						}
						case "Stream":
						{
#>
										var resultAsInt64 = TryUnpackInt64( source, typeCode );
<#
							break;
						}
					}
#>
										if ( resultAsInt64.HasValue )
										{
											return resultAsInt64.Value;
										}
										else
										{
<#
					switch( __sourceType )
					{
						case "byte[]":
						{
#>
											var resultAsUInt64 = TryUnpackUInt64( source, offset );
<#
							break;
						}
						case "Stream":
						{
#>
											var resultAsUInt64 = TryUnpackUInt64( source, typeCode );
<#
							break;
						}
					}
#>
<#
					if( __sourceType == "byte[]" )
					{
#>
											if ( resultAsUInt64.HasValue && resultAsUInt64.Value.Value <= Int64.MaxValue )
											{
												return new <#= __returnType #>( ( <#= __type.Name #> )resultAsUInt64.Value.Value, resultAsUInt64.Value.NewOffset );
											}
<#
					}
					else
					{
#>
											if ( resultAsUInt64.HasValue && resultAsUInt64.Value <= Int64.MaxValue )
											{
												return ( <#= __returnType #> )resultAsUInt64.Value;
											}
<#
					}
#>
										}
									}
								}
							}
						}
					}
				}
			}
<#
				} // !int
			} //  !short
		} // !sbyte
	}
	else
	{
#>
			unchecked
			{
<#
		switch( __sourceType )
		{
			case "byte[]":
			{
#>
				var resultAsUInt8 = TryUnpackByte( source, offset );
<#
				break;
			}
			case "Stream":
			{
#>
				var resultAsUInt8 = TryUnpackByte( source, typeCode );
<#
				break;
			}
		}
#>
				if ( resultAsUInt8.HasValue )
				{
<#
			if( __sourceType == "byte[]" )
			{
#>
					return new <#= __returnType #>( resultAsUInt8.Value.Value, resultAsUInt8.Value.NewOffset );
<#
			}
			else
			{
#>
					return resultAsUInt8.Value;
<#
			}
#>
				}
				else
				{
<#
		switch( __sourceType )
		{
			case "byte[]":
			{
#>
					var resultAsInt8 = TryUnpackSByte( source, offset );
<#
				break;
			}
			case "Stream":
			{
#>
					var resultAsInt8 = TryUnpackSByte( source, typeCode );
<#
				break;
			}
		}
#>
<#
		if( __sourceType == "byte[]" )
		{
#>
					if ( resultAsInt8.HasValue && resultAsInt8.Value.Value >= 0 )
					{
						return new <#= __returnType #>( ( <#= __type.Name #> )resultAsInt8.Value.Value, resultAsInt8.Value.NewOffset );
					}
<#
		}
		else
		{
#>
					if ( resultAsInt8.HasValue && resultAsInt8.Value >= 0 )
					{
						return ( <#= __returnType #> )resultAsInt8.Value;
					}
<#
		}

		if( __type == typeof( byte ) )
		{
#>
				}
			}
<#
		}
		else
		{
#>
					else
					{
<#
			switch( __sourceType )
			{
				case "byte[]":
				{
#>
						var resultAsUInt16 = TryUnpackUInt16( source, offset );
<#
					break;
				}
				case "Stream":
				{
#>
						var resultAsUInt16 = TryUnpackUInt16( source, typeCode );
<#
					break;
				}
			}
#>
						if ( resultAsUInt16.HasValue )
						{
<#
			if( __sourceType == "byte[]" )
			{
#>
							return new <#= __returnType #>( resultAsUInt16.Value.Value, resultAsUInt16.Value.NewOffset );
<#
			}
			else
			{
#>
							return resultAsUInt16.Value;
<#
			}
#>
						}
						else
						{
<#
			switch( __sourceType )
			{
				case "byte[]":
				{
#>
							var resultAsInt16 = TryUnpackInt16( source, offset );
<#
					break;
				}
				case "Stream":
				{
#>
							var resultAsInt16 = TryUnpackInt16( source, typeCode );
<#
					break;
				}
			}
#>
<#
			if( __sourceType == "byte[]" )
			{
#>
							if ( resultAsInt16.HasValue && resultAsInt16.Value.Value >= 0 )
							{
								return new <#= __returnType #>( ( <#= __type.Name #> )resultAsInt16.Value.Value, resultAsInt16.Value.NewOffset );
							}
<#
			}
			else
			{
#>
							if ( resultAsInt16.HasValue && resultAsInt16.Value >= 0 )
							{
								return ( <#= __returnType #> )resultAsInt16.Value;
							}
<#
			}

			if( __type == typeof( ushort ) )
			{
#>	
						}
					}
				}
			}
<#
		}
		else
		{
#>
							else
							{
<#
			switch( __sourceType )
			{
				case "byte[]":
				{
#>
								var resultAsUInt32 = TryUnpackUInt32( source, offset );
<#
					break;
				}
				case "Stream":
				{
#>
								var resultAsUInt32 = TryUnpackUInt32( source, typeCode );
<#
					break;
				}
			}
#>
								if ( resultAsUInt32.HasValue )
								{
<#
			if( __sourceType == "byte[]" )
			{
#>
									return new <#= __returnType #>( resultAsUInt32.Value.Value, resultAsUInt32.Value.NewOffset );
<#
			}
			else
			{
#>
									return resultAsUInt32.Value;
<#
			}
#>
								}
								else
								{
<#
				switch( __sourceType )
				{
					case "byte[]":
					{
#>
									var resultAsInt32 = TryUnpackInt32( source, offset );
<#
						break;
					}
					case "Stream":
					{
#>
									var resultAsInt32 = TryUnpackInt32( source, typeCode );
<#
						break;
					}
				}
#>
<#
				if( __sourceType == "byte[]" )
				{
#>
									if ( resultAsInt32.HasValue && resultAsInt32.Value.Value >= 0 )
									{
										return new <#= __returnType #>( ( <#= __type.Name #> )resultAsInt32.Value.Value, resultAsInt32.Value.NewOffset );
									}
<#
				}
				else
				{
#>
									if ( resultAsInt32.HasValue && resultAsInt32.Value >= 0 )
									{
										return ( <#= __returnType #> )resultAsInt32.Value;
									}
<#
				}
				if( __type == typeof( uint ) )
				{
#>
								}
							}
						}
					}
				}
			}
<#
				}
				else
				{
#>
									else
									{
<#
					switch( __sourceType )
					{
						case "byte[]":
						{
#>
										var resultAsUInt64 = TryUnpackUInt64( source, offset );
<#
							break;
						}
						case "Stream":
						{
#>
										var resultAsUInt64 = TryUnpackUInt64( source, typeCode );
<#
							break;
						}
					}
#>
										if ( resultAsUInt64.HasValue )
										{
											return resultAsUInt64.Value;
										}
										else
										{
<#
					switch( __sourceType )
					{
						case "byte[]":
						{
#>
											var resultAsInt64 = TryUnpackInt64( source, offset );
<#
							break;
						}
						case "Stream":
						{
#>
											var resultAsInt64 = TryUnpackInt64( source, typeCode );
<#
							break;
						}
					}

					if( __sourceType == "byte[]" )
					{
#>
											if ( resultAsInt64.HasValue && resultAsInt64.Value.Value >= 0 )
											{
												return new <#= __returnType #>( ( <#= __type.Name #> )resultAsInt64.Value.Value, resultAsInt64.Value.NewOffset );
											}
<#
					}
					else
					{
#>
											if ( resultAsInt64.HasValue && resultAsInt64.Value >= 0 )
											{
												return ( <#= __returnType #> )resultAsInt64.Value;
											}
<#
					}
#>
										}
									}
								}
							}
						}
					}
				}
			}
<#
				} // !uint
			} //  !ushort
		} // !byte
	}
#>
			throw new MessageTypeException( "Not <#= __type.Name #>." );
		}
<#
}

foreach( var __type in __integerTypes )
foreach( var __sourceType in __sourceTypes )
{
#>

<#
	switch( __sourceType )
	{
		case "Stream" :
		{
#>
		internal static <#= __type.Name #>? TryUnpack<#= __type.Name #>( Stream source, byte typeCode )
		{
<#
			break;
		}
		case "byte[]" :
		{
#>
		internal static UnpackArrayResult<<#= __type.Name #>>? TryUnpack<#= __type.Name #>( byte[] source, int offset )
		{
			if( source.Length <= offset )
			{
				throw new UnpackException( "Type header not found." );
			}

			int typeCode = source[ offset ];
<#
			break;
		}
	}
#>
<#
	if( __type == typeof( byte ) )
	{
#>
			if ( ( typeCode & 0x80 ) == 0  )   // Positive Fixnum
			{
				// It is positive fixnum value itself.
<# 
		if( __sourceType == "byte[]" )
		{
#>
				return new UnpackArrayResult<byte>( ( byte )typeCode, offset +1 );
<#
		}
		else
		{
#>
				return unchecked( ( byte )typeCode );
<#
		}
#>
			}
<#
	}
	else if( __type == typeof( sbyte ) )
	{
#>
			if ( ( typeCode & 0x80 ) == 0 || ( typeCode & 0xe0 ) == 0xe0 )   // Fixnum
			{
				// It is positive or negative fixnum value itself.
<# 
		if( __sourceType == "byte[]" )
		{
#>
				return new UnpackArrayResult<sbyte>( ( sbyte )typeCode, offset + 1 );
<#
		}
		else
		{
#>
				return unchecked( ( sbyte )typeCode );
<#
		}
#>
			}
<#
	}
#>
			if( typeCode != <#= __typeCodes[ __type ] #> )
			{
				return null;
			}

<#
		if( __sourceType == "byte[]" )
		{
#>
			return new UnpackArrayResult<<#= __type.Name #>>( Unpack<#= __type.Name #>Body( source, offset + 1 ), offset + sizeof( <#= __csharpPrimitives[ __type ] #> ) + 1 );
		}

		private static <#= __type.Name #> Unpack<#= __type.Name #>Body( <#= __sourceType #> source, int offset )
		{
<#
		}
		else
		{
#>
			return Unpack<#= __type.Name #>Body( source );
		}

		private static <#= __type.Name #> Unpack<#= __type.Name #>Body( <#= __sourceType #> source )
		{
<#
		}
	switch( __sourceType )
	{
		case "byte[]" :
		{
#>
			if( source.Length < offset + <#= Marshal.SizeOf( __type ) #> )
			{
				throw new UnpackException( "Insufficient array buffer length." );
			}
<#
			break;
		}
		case "Stream" :
		{
#>
			if( source.Length < source.Position + <#= Marshal.SizeOf( __type ) #> )
			{
				throw new UnpackException( "Insufficient stream length." );
			}
<#
			break;
		}
	}

#>
<#
	for( int __i = 0; __i < Marshal.SizeOf( __type ); __i++ )
	{
		switch( __sourceType )
		{
			case "Stream":
			{
#>
			var byte<#= __i #> = ( byte )source.ReadByte();
<#
				break;
			}
			case "byte[]":
			{
#>
			var byte<#= __i #> = source[ offset + <#= __i #> ];
<#
				break;
			}
		}
	}

	String __valueTypeName;
	if( __type == typeof( byte ) || __type == typeof( sbyte ) )
	{
		__valueTypeName = "byte";
	}
	else if( !__isUnsigned( __type ) )
	{
		__valueTypeName = "U" + __type.Name;
	}
	else
	{
		__valueTypeName = __type.Name;
	}

	if( __type == typeof( byte ) )
	{
#>
			return byte0;
<#
	}
	else if( __type == typeof( sbyte ) )
	{
#>
			return unchecked( ( sbyte )byte0 );
<#
	}
	else
	{
#>
			<#= __valueTypeName #> result = 0;
			unchecked
			{
<#
		for( int __i = 0; __i < Marshal.SizeOf( __type ); __i++ )
		{
#>
				result |= ( <#= __valueTypeName #> )( ( <#= __valueTypeName #> )byte<#= __i #> <#= ( Marshal.SizeOf( __type ) - __i > 1 ) ? "<< " + ( 8 * ( Marshal.SizeOf( __type ) - __i - 1 ) ) : "" #> );
<#
		}
#>
			}

			return ( <#= __type.Name #> )result;
<#
	}
#>
		}
<#
}
#>
	}
}
