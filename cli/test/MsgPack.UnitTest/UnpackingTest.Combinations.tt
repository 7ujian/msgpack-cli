<#
//
// MessagePack for CLI
//
// Copyright (C) 2010 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="System.Numerics" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Numerics" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#

var __integerValues=
	new Dictionary<string, TestCase>()
	{
		{ "Int64MinValue", new TestCase(){ Value = new BigInteger( Int64.MinValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }"
		 } } },
		{ "Int32MinValueMinusOne", new TestCase(){ Value = new BigInteger( Int32.MinValue -1L), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF }"
		 } } },
		{ "Int32MinValue", new TestCase(){ Value = new BigInteger( Int32.MinValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00 }",
			"new byte[] { 0xD2, 0x80, 0x00, 0x00, 0x00 }"
		 } } },
		{ "Int16MinValueMinusOne", new TestCase(){ Value = new BigInteger( Int16.MinValue - 1  ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0x7F, 0xFF }"
		 } } },
		{ "Int16MinValue", new TestCase(){ Value = new BigInteger( Int16.MinValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00 }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0x80, 0x00 }",
			"new byte[] { 0xD1, 0x80, 0x00 }"
		 } } },
		{ "SByteMinValueMinusOne", new TestCase(){ Value = new BigInteger( SByte.MinValue - 1 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0xFF, 0x7F }",
			"new byte[] { 0xD1, 0xFF, 0x7F }"
		 } } },
		{ "SByteMinValue", new TestCase(){ Value = new BigInteger( SByte.MinValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80 }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0xFF, 0x80 }",
			"new byte[] { 0xD1, 0xFF, 0x80 }",
			"new byte[] { 0xD0, 0x80 }"
		 } } },
		{ "NegativeFixNumMinValueMinusOne", new TestCase(){ Value = new BigInteger( -33 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0xFF, 0xDF }",
			"new byte[] { 0xD1, 0xFF, 0xDF }",
			"new byte[] { 0xD0, 0xDF }"
		 } } },
		{ "NegativeFixNumMinValue", new TestCase(){ Value = new BigInteger( -32 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0 }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0xFF, 0xE0 }",
			"new byte[] { 0xD1, 0xFF, 0xE0 }",
			"new byte[] { 0xD0, 0xE0 }",
			"new byte[] { 0xE0 }"
		 } } },
		{ "MinusOne", new TestCase(){ Value = new BigInteger( -1 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }",
			"new byte[] { 0xD2, 0xFF, 0xFF, 0xFF, 0xFF }",
			"new byte[] { 0xD1, 0xFF, 0xFF }",
			"new byte[] { 0xD0, 0xFF }",
			"new byte[] { 0xFF }"
		 } } },
		{ "Zero", new TestCase(){ Value = new BigInteger( 0 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }",
			"new byte[] { 0xD2, 0x00, 0x00, 0x00, 0x00 }",
			"new byte[] { 0xCE, 0x00, 0x00, 0x00, 0x00 }",
			"new byte[] { 0xD1, 0x00, 0x00 }",
			"new byte[] { 0xCD, 0x00, 0x00 }",
			"new byte[] { 0xD0, 0x00 }",
			"new byte[] { 0xCC, 0x00 }",
			"new byte[] { 0x00 }"
		 } } },
		{ "PlusOne", new TestCase(){ Value = new BigInteger( 1 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }",
			"new byte[] { 0xD2, 0x00, 0x00, 0x00, 0x01 }",
			"new byte[] { 0xCE, 0x00, 0x00, 0x00, 0x01 }",
			"new byte[] { 0xD1, 0x00, 0x01 }",
			"new byte[] { 0xCD, 0x00, 0x01 }",
			"new byte[] { 0xD0, 0x01 }",
			"new byte[] { 0xCC, 0x01 }",
			"new byte[] { 0x01 }"
		 } } },
		{ "PositiveFixNumMaxValue", new TestCase(){ Value = new BigInteger( 127 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F }",
			"new byte[] { 0xD2, 0x00, 0x00, 0x00, 0x7F }",
			"new byte[] { 0xCE, 0x00, 0x00, 0x00, 0x7F }",
			"new byte[] { 0xD1, 0x00, 0x7F }",
			"new byte[] { 0xCD, 0x00, 0x7F }",
			"new byte[] { 0xD0, 0x7F }",
			"new byte[] { 0xCC, 0x7F }",
			"new byte[] { 0x7F }"
		 } } },
		{ "PositiveFixNumMaxValuePlusOne", new TestCase(){ Value = new BigInteger( 0x80 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 }",
			"new byte[] { 0xD2, 0x00, 0x00, 0x00, 0x80 }",
			"new byte[] { 0xCE, 0x00, 0x00, 0x00, 0x80 }",
			"new byte[] { 0xD1, 0x00, 0x80 }",
			"new byte[] { 0xCD, 0x00, 0x80 }",
			"new byte[] { 0xCC, 0x80 }",
		 } } },
		{ "ByteMaxValue", new TestCase(){ Value = new BigInteger( Byte.MaxValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF }",
			"new byte[] { 0xD2, 0x00, 0x00, 0x00, 0xFF }",
			"new byte[] { 0xCE, 0x00, 0x00, 0x00, 0xFF }",
			"new byte[] { 0xD1, 0x00, 0xFF }",
			"new byte[] { 0xCD, 0x00, 0xFF }",
			"new byte[] { 0xCC, 0xFF }",
		 } } },
		{ "ByteMaxValuePlusOne", new TestCase(){ Value = new BigInteger( Byte.MaxValue + 1 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00 }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00 }",
			"new byte[] { 0xD2, 0x00, 0x00, 0x01, 0x00 }",
			"new byte[] { 0xCE, 0x00, 0x00, 0x01, 0x00 }",
			"new byte[] { 0xD1, 0x01, 0x00 }",
			"new byte[] { 0xCD, 0x01, 0x00 }",
		 } } },
		{ "UInt16MaxValue", new TestCase(){ Value = new BigInteger( UInt16.MaxValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF }",
			"new byte[] { 0xD2, 0x00, 0x00, 0xFF, 0xFF }",
			"new byte[] { 0xCE, 0x00, 0x00, 0xFF, 0xFF }",
			"new byte[] { 0xCD, 0xFF, 0xFF }",
		 } } },
		{ "UInt16MaxValuePlusOne", new TestCase(){ Value = new BigInteger( UInt16.MaxValue + 1 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 }",
			"new byte[] { 0xD2, 0x00, 0x01, 0x00, 0x00 }",
			"new byte[] { 0xCE, 0x00, 0x01, 0x00, 0x00 }",
		 } } },
		{ "UInt32MaxValue", new TestCase(){ Value = new BigInteger( UInt32.MaxValue ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF }",
			"new byte[] { 0xCE, 0xFF, 0xFF, 0xFF, 0xFF }",
		 } } },
		{ "UInt32MaxValuePlusOne", new TestCase(){ Value = new BigInteger( ( ulong )UInt32.MaxValue + 1 ), Expressions = new [] { 
			"new byte[] { 0xD3, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }",
			"new byte[] { 0xCF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }",
		 } } },
		{ "UInt64MaxValue", new TestCase(){ Value = new BigInteger( UInt64.MaxValue ), Expressions = new [] { 
			"new byte[] { 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }",
		 } } },	};

var __realValues =
	new Tuple<string, string, Type, string, string>[]
	{
		Tuple.Create( "SingleMinValue", "new byte[] { 0xCA, 0xFF, 0x7F, 0xFF, 0xFF }", typeof( float ), "Single.MinValue.Equals(", "( ( double )Single.MinValue ).Equals(" ),
		Tuple.Create( "SingleMaxValue", "new byte[] { 0xCA, 0x7F, 0x7F, 0xFF, 0xFF }", typeof( float ), "Single.MaxValue.Equals(", "( ( double )Single.MaxValue ).Equals(" ),
		Tuple.Create( "SingleZero", "new byte[] { 0xCA, 0x00, 0x00, 0x00, 0x00 }", typeof( float ), "( 0.0f ).Equals(", "( 0.0 ).Equals(" ),
		Tuple.Create( "DoubleMinValue", "new byte[] { 0xCB, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }", typeof( double ), "Double.MinValue.Equals(", "( ( float )Double.MinValue ).Equals(" ),
		Tuple.Create( "DoubleMaxValue", "new byte[] { 0xCB, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }", typeof( double ), "Double.MaxValue.Equals(", "( ( float )Double.MaxValue ).Equals(" ),
		Tuple.Create( "DoubleZero", "new byte[] { 0xCB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }", typeof( double ), "( 0.0 ).Equals(", "( 0.0f ).Equals("  ),
	};
	
var __arrayValues=
	new Tuple<string, string, string[]>[]
	{
		Tuple.Create( "FixArray0Value", "0", new [] { 
			"new byte[] { 0x90 }",
			"new byte[] { 0xDC, 0x00, 0x00 }",
			"new byte[] { 0xDD, 0x00, 0x00, 0x00, 0x00 }",
		} ),
		Tuple.Create( "FixArray1Value", "1", new [] { 
			"new byte[] { 0x91, " + String.Join( ", ", Enumerable.Repeat( "0x57", 1 ) ) + " }",
			"new byte[] { 0xDC, 0x00, 0x01, 0x01, " + String.Join( ", ", Enumerable.Repeat( "0x57", 1 ) ) + " }",
			"new byte[] { 0xDD, 0x00, 0x00, 0x00, 0x01, 0x01, " + String.Join( ", ", Enumerable.Repeat( "0x57", 1 ) ) + " }",
		} ),
		Tuple.Create( "FixArrayMaxValue", "0xF", new [] { 
			"new byte[] { 0x9F, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xF ) ) + " }",
			"new byte[] { 0xDC, 0x00, 0x0F, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xF ) ) + " }",
			"new byte[] { 0xDD, 0x00, 0x00, 0x00, 0x0F, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xF ) ) + " }",
		} ),
		Tuple.Create( "Array16MinValue", "0x10", new [] { 
			"new byte[] { 0xDC, 0x00, 0x10, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0x10 ) ) + " }",
			"new byte[] { 0xDD, 0x00, 0x00, 0x00, 0x10, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0x10 ) ) + " }",
		} ),
		Tuple.Create( "Array16MaxValue", "0xFFFF", new [] { 
			"new byte[] { 0xDC, 0xFF, 0xFF, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xFFFF ) ) + " }",
			"new byte[] { 0xDD, 0x00, 0x00, 0xFF, 0xFF, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xFFFF ) ) + " }",
		} ),
		Tuple.Create( "Array32MinValue", "0x10000", new [] { 
			"new byte[] { 0xDD, 0x00, 0x01, 0x00, 0x00, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0x10000 ) ) + " }",
		} ),
	};

var __mapValues=
	new Tuple<string, string, string[]>[]
	{
		Tuple.Create( "FixMap0Value", "0", new [] { 
			"new byte[] { 0x80 }",
			"new byte[] { 0xDE, 0x00, 0x00 }",
			"new byte[] { 0xDF, 0x00, 0x00, 0x00, 0x00 }",
		} ),
		Tuple.Create( "FixMap1Value", "0x1", new [] { 
			"new byte[] { 0x81, " + String.Join( ", ", Enumerable.Repeat( "0x57", 1 * 2 ) ) + " }",
			"new byte[] { 0xDE, 0x00, 0x01, 0x01, " + String.Join( ", ", Enumerable.Repeat( "0x57", 1 * 2 ) ) + " }",
			"new byte[] { 0xDF, 0x00, 0x00, 0x00, 0x01, 0x01, " + String.Join( ", ", Enumerable.Repeat( "0x57", 1 * 2 ) ) + " }",
		} ),
		Tuple.Create( "FixMapMaxValue", "0xF", new [] { 
			"new byte[] { 0x8F, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xF * 2 ) ) + " }",
			"new byte[] { 0xDE, 0x00, 0x0F, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xF * 2 ) ) + " }",
			"new byte[] { 0xDF, 0x00, 0x00, 0x00, 0x0F, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xF * 2 ) ) + " }",
		} ),
		Tuple.Create( "Map16MinValue", "0x10", new [] { 
			"new byte[] { 0xDE, 0x00, 0x10, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0x10 * 2 ) ) + " }",
			"new byte[] { 0xDF, 0x00, 0x00, 0x00, 0x10, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0x10  * 2) ) + " }",
		} ),
		Tuple.Create( "Map16MaxValue", "0xFFFF", new [] { 
			"new byte[] { 0xDE, 0xFF, 0xFF, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xFFFF * 2 ) ) + " }",
			"new byte[] { 0xDF, 0x00, 0x00, 0xFF, 0xFF, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0xFFFF * 2 ) ) + " }",
		} ),
		Tuple.Create( "Map32MinValue", "0x10000", new [] { 
			"new byte[] { 0xDF, 0x00, 0x01, 0x00, 0x00, " + String.Join( ", ", Enumerable.Repeat( "0x57", 0x10000 * 2 ) ) + " }",
		} ),
	};

var __binaryValues=
	new Tuple<string, string, string[]>[]
	{
		Tuple.Create( "FixRaw0Value", "0", new [] { 
			"new byte[] { 0xA0 }",
			"new byte[] { 0xDA, 0x00, 0x00 }",
			"new byte[] { 0xDB, 0x00, 0x00, 0x00, 0x00 }",
		} ),
		Tuple.Create( "FixRaw1Value", "0x1", new [] { 
			"new byte[] { 0xA1, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 1 ) ) + " }",
			"new byte[] { 0xDA, 0x00, 0x01, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 1 ) ) + " }",
			"new byte[] { 0xDB, 0x00, 0x00, 0x00, 0x01, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 1 ) ) + " }",
		} ),
		Tuple.Create( "FixRawMaxValue", "0x1F", new [] { 
			"new byte[] { 0xBF, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0x1F ) ) + " }",
			"new byte[] { 0xDA, 0x00, 0x1F, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0x1F ) ) + " }",
			"new byte[] { 0xDB, 0x00, 0x00, 0x00, 0x1F, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0x1F ) ) + " }",
		} ),
		Tuple.Create( "Raw16MinValue", "0x20", new [] { 
			"new byte[] { 0xDA, 0x00, 0x20, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0x20 ) ) + " }",
			"new byte[] { 0xDB, 0x00, 0x00, 0x00, 0x20, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0x20 ) ) + " }",
		} ),
		Tuple.Create( "Raw16MaxValue", "0xFFFF", new [] { 
			"new byte[] { 0xDA, 0xFF, 0xFF, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0xFFFF ) ) + " }",
			"new byte[] { 0xDB, 0x00, 0x00, 0xFF, 0xFF, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0xFFFF ) ) + " }",
		} ),
		Tuple.Create( "Raw32MinValue", "0x10000", new [] { 
			"new byte[] { 0xDB, 0x00, 0x01, 0x00, 0x00, " + String.Join( ", ", Enumerable.Repeat( "0xFF", 0x10000 ) ) + " }",
		} ),
	};

var __miscValues =
	new Dictionary<string, string>()
	{
		{ "Nil",  "new byte[] { 0xC0 }" },
		{ "True", "new byte[] { 0xC3 }" },
		{ "False", "new byte[] { 0xC2 }" },
	};
	
var __integerTypes =
	new []
	{
		typeof( sbyte ),
		typeof( byte ),
		typeof( short ),
		typeof( ushort ),
		typeof( int ),
		typeof( uint ),
		typeof( long ),
		typeof( ulong ),
	};

var __realTypes =
	new []
	{
		typeof( float ),
		typeof( double )
	};

string __errorTemplate =
@"[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void Test{0}_ByteArray_{1}_Fail()
		{{{{
			Unpacking.{0}( {2} );
		}}}}

		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void Test{0}_Stream_{1}_Fail()
		{{{{
			using( var buffer = new MemoryStream( {2} ) )
			{{{{
				Unpacking.{0}( buffer );
			}}}}
		}}}}

";
	
string __argumentErrorTemplate =
@"[Test]
		[ExpectedException( typeof( ArgumentException ) )]
		public void TestUnpack{0}_ByteArray_Empty()
		{{
			Unpacking.Unpack{0}( new byte[ 0 ] );
		}}

		[Test]
		[ExpectedException( typeof( ArgumentNullException ) )]
		public void TestUnpack{0}_ByteArray_Null()
		{{
			Unpacking.Unpack{0}( default( byte[] ) );
		}}

		[Test]
		[ExpectedException( typeof( ArgumentNullException ) )]
		public void TestUnpack{0}_ByteArray_Offset_Null()
		{{
			Unpacking.Unpack{0}( default( byte[] ), 0 );
		}}

		[Test]
		[ExpectedException( typeof( ArgumentOutOfRangeException ) )]
		public void TestUnpack{0}_ByteArray_Offset_OffsetIsNegative()
		{{
			Unpacking.Unpack{0}( new byte[]{{ 0x1 }}, -1 );
		}}

		[Test]
		[ExpectedException( typeof( ArgumentException ) )]
		public void TestUnpack{0}_ByteArray_Offset_OffsetIsTooBig()
		{{
			Unpacking.Unpack{0}( new byte[]{{ 0x1 }}, 1 );
		}}

		[Test]
		[ExpectedException( typeof( ArgumentException ) )]
		public void TestUnpack{0}_ByteArray_Offset_Empty()
		{{
			Unpacking.Unpack{0}( new byte[ 0 ], 0 );
		}}

		[Test]
		[ExpectedException( typeof( ArgumentNullException ) )]
		public void TestUnpack{0}_Stream_Null()
		{{
			Unpacking.Unpack{0}( default( Stream ) );
		}}";

string[] __arrayErrorCases = 
	__arrayValues.SelectMany( tuple =>
		tuple.Item3.Select( expression =>
			String.Format( CultureInfo.InvariantCulture, __errorTemplate, "{0}", tuple.Item1, EscapeFormatString( expression ) )
		)
	).ToArray();

	string[] __mapErrorCases =
	__mapValues.SelectMany( tuple =>
		tuple.Item3.Select( expression =>
			String.Format( CultureInfo.InvariantCulture, __errorTemplate, "{0}", tuple.Item1, EscapeFormatString( expression ) )
		)
	).ToArray();
	
string[] __binaryErrorCases =
	__binaryValues.SelectMany( tuple =>
		tuple.Item3.Select( expression =>
			String.Format( CultureInfo.InvariantCulture, __errorTemplate, "{0}", tuple.Item1, EscapeFormatString( expression ) )
		)
	).ToArray();

var __collectionErrorCases =
	__arrayErrorCases.Concat( __mapErrorCases ).Concat( __binaryErrorCases ).ToArray();
#>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using NUnit.Framework;

namespace MsgPack
{
<#
/******************************** INTEGER ********************************/
foreach( var __integerType in __integerTypes )
{
#>
	partial class UnpackingTest_Combinations_<#= __integerType.Name #>
	{
<#
	var __minValue = BigInteger.Parse( __integerType.GetField( "MinValue" ).GetValue( null ).ToString() );
	var __maxValue = BigInteger.Parse( __integerType.GetField( "MaxValue" ).GetValue( null ).ToString() );
	
	foreach( var __integerValue in __integerValues )
	{
		TestCase __testCase = __integerValue.Value;
		var __isNotCompatible =
			__testCase.Value < __minValue || __maxValue < __testCase.Value;
		foreach( var __expression in __testCase.Expressions )
		{
#>
		[Test]
<#
			if( __isNotCompatible )
			{
#>
		[ExpectedException( typeof( MessageTypeException ) )]
<#
			}
#>
		public void TestUnpack<#= __integerType.Name #>_ByteArray_<#= __integerValue.Key #>As<#= ToValueId( __expression ) #>_<#= __isNotCompatible ? "AsIs" : "Fail" #>()
		{
			var result = Unpacking.Unpack<#= __integerType.Name #>( <#= __expression #> );
<#
			if( !__isNotCompatible )
			{
#>
			Assert.AreEqual( <#= __expression.Count( c => c == ',' ) + 1 #>, result.ReadCount );
			Assert.AreEqual( <#= __testCase.Value #>L, result.Value );
<#
			}
#>
		}
		
		[Test]
<#
			if( __isNotCompatible )
			{
#>
		[ExpectedException( typeof( MessageTypeException ) )]
<#
			}
#>
		public void TestUnpack<#= __integerType.Name #>_Stream_<#= __integerValue.Key #>As<#= ToValueId( __expression ) #>_<#= __isNotCompatible ? "AsIs" : "Fail" #>()
		{
			using( var buffer = new MemoryStream( <#= __expression #> ) )
			{
				var result = Unpacking.Unpack<#= __integerType.Name #>( buffer );
<#
			if( !__isNotCompatible )
			{
#>
				Assert.AreEqual( <#= __expression.Count( c => c == ',' ) + 1 #>, buffer.Position );
				Assert.AreEqual( <#= __testCase.Value #>L, result );
<#
			}
#>
			}
		}
		
<#
		}
	}
#>
		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, __integerType.Name ) #>

		[Test]
		public void TestUnpack<#= __integerType.Name #>_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			// Offset 1 is positive fix num 1.
			var result = Unpacking.Unpack<#= __integerType.Name #>( new byte[]{ 0xFF, 0x57, 0xFF }, 1 );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( 0x57, result.Value );
		}
	}
	
<#
}

/******************************** REAL ********************************/

foreach( var __realType in __realTypes )
{
#>
	partial class UnpackingTest_Combinations_<#= __realType.Name #>
	{
<#
	foreach( var __realValue in __realValues )
	{
#>
		[Test]
		public void TestUnpack<#= __realType.Name #>_ByteArray_<#= __realValue.Item1 #>_AsIs()
		{
			var result = Unpacking.Unpack<#= __realType.Name #>( <#= __realValue.Item2 #> );
			Assert.AreEqual( sizeof( <#= __realValue.Item3 #> ) + 1, result.ReadCount );
			Assert.IsTrue( <#= __realType == __realValue.Item3 ? __realValue.Item4 : __realValue.Item5 #>result.Value ) );
		}
		
		[Test]
		public void TestUnpack<#= __realType.Name #>_Stream_<#= __realValue.Item1 #>_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __realValue.Item2 #> ) )
			{
				var result = Unpacking.Unpack<#= __realType.Name #>( buffer );
				Assert.AreEqual( sizeof( <#= __realValue.Item3 #> ) + 1, buffer.Position );
				Assert.IsTrue( <#= __realType == __realValue.Item3 ? __realValue.Item4 : __realValue.Item5 #>result ) );
			}
		}
		
<#
	}
#>
		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, __realType.Name ) #>

		[Test]
		public void TestUnpack<#= __realType.Name #>_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			// Offset 1 is <#= __realType.Name #> 0.
			var result = Unpacking.Unpack<#= __realType.Name #>( new byte[]{ 0xFF, <#= __realType == typeof( float ) ? "0xCA" : "0xCB" #>, <#= String.Join( ", ", Enumerable.Repeat( "0x00", __realType == typeof( float ) ? 4 : 8 ) ) #>, 0xFF }, 1 );
			Assert.AreEqual( sizeof( <#= __realType #> ) + 1, result.ReadCount );
			Assert.AreEqual( 0.0, result.Value );
		}
	}
	
<#
}

/******************************** BOOLEAN ********************************/
#>
	partial class UnpackingTest_Combinations_Boolean
	{
		[Test]
		public void TestUnpackBoolean_ByteArray_True_AsIs()
		{
			var result = Unpacking.UnpackBoolean( <#= __miscValues[ "True" ] #> );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( true, result.Value );
		}
		
		[Test]
		public void TestUnpackBoolean_Stream_True_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __miscValues[ "True" ] #> ) )
			{
				var result = Unpacking.UnpackBoolean( buffer );
				Assert.AreEqual( 1, buffer.Position );
				Assert.AreEqual( true, result );
			}
		}

		[Test]
		public void TestUnpackBoolean_ByteArray_False_AsIs()
		{
			var result = Unpacking.UnpackBoolean( <#= __miscValues[ "False" ] #> );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( false, result.Value );
		}
		
		[Test]
		public void TestUnpackBoolean_Stream_False_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __miscValues[ "False" ] #> ) )
			{
				var result = Unpacking.UnpackBoolean( buffer );
				Assert.AreEqual( 1, buffer.Position );
				Assert.AreEqual( false, result );
			}
		}
		
		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void TestUnpackBoolean_ByteArray_Nil()
		{
			var result = Unpacking.UnpackBoolean( <#= __miscValues[ "Nil" ] #> );
		}
		
		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void TestUnpackBoolean_Stream_Nil()
		{
			using( var buffer = new MemoryStream( <#= __miscValues[ "Nil" ] #> ) )
			{
				var result = Unpacking.UnpackBoolean( buffer );
			}
		}

		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, "Boolean" ) #>

		[Test]
		public void TestUnpackBoolean_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			// Offset 1 is true
			var result = Unpacking.UnpackBoolean( new byte[]{ 0xFF, 0xC3, 0xFF }, 1 );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( true, result.Value );
		}
	}
	
<#
/******************************** NIL ********************************/
#>
	partial class UnpackingTest_Combinations_Nil
	{
		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void TestUnpackNull_ByteArray_True()
		{
			var result = Unpacking.UnpackNull( <#= __miscValues[ "True" ] #> );
		}
		
		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void TestUnpackNull_Stream_True()
		{
			using( var buffer = new MemoryStream( <#= __miscValues[ "True" ] #> ) )
			{
				var result = Unpacking.UnpackNull( buffer );
			}
		}

		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void TestUnpackNull_ByteArray_False()
		{
			var result = Unpacking.UnpackNull( <#= __miscValues[ "False" ] #> );
		}
		
		[Test]
		[ExpectedException( typeof( MessageTypeException ) )]
		public void TestUnpackNull_Stream_False()
		{
			using( var buffer = new MemoryStream( <#= __miscValues[ "False" ] #> ) )
			{
				var result = Unpacking.UnpackNull( buffer );
			}
		}
		
		[Test]
		public void TestUnpackNull_ByteArray_AsIs()
		{
			var result = Unpacking.UnpackNull( <#= __miscValues[ "Nil" ] #> );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.IsNull( result.Value );
		}
		
		[Test]
		public void TestUnpackNull_Stream_Nil_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __miscValues[ "Nil" ] #> ) )
			{
				var result = Unpacking.UnpackNull( buffer );
				Assert.AreEqual( 1, buffer.Position );
				Assert.IsNull( result );
			}
		}

		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, "Null" ) #>

		[Test]
		public void TestUnpackNull_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			var result = Unpacking.UnpackNull( new byte[]{ 0xFF, 0xC0, 0xFF }, 1 );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.IsNull( result.Value );
		}
	}
	
<#
/******************************** ARRAY ********************************/
#>
	partial class UnpackingTest_Combinations_Array
	{
<#
foreach( var __testCase in __arrayValues )
{
	foreach( var __expression in __testCase.Item3 )
	{
#>
		[Test]
		public void TestUnpackArrayLength_ByteArray_<#= __testCase.Item1 #>_As<#= ToValueId( __expression ) #>_AsIs()
		{
			var result = Unpacking.UnpackArrayLength( <#= __expression #> );
			Assert.AreEqual( <#= GetHeaderLength( __expression ) #>, result.ReadCount );
			Assert.AreEqual( <#= __testCase.Item2 #>, result.Value );
		}

		[Test]
		public void TestUnpackArrayLength_Stream_<#= __testCase.Item1 #>_As<#= ToValueId( __expression ) #>_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __expression #> ) )
			{
				var result = Unpacking.UnpackArrayLength( buffer );
				Assert.AreEqual( <#= GetHeaderLength( __expression ) #>, buffer.Position );
				Assert.AreEqual( <#= __testCase.Item2 #>, result );
			}
		}
		
<#
	}
}
#>
		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, "ArrayLength" ) #>

		[Test]
		public void TestUnpackArrayLength_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			var result = Unpacking.UnpackArrayLength( new byte[]{ 0xFF, 0x90, 0xFF }, 1 );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( 0, result.Value );
		}
	}

<#

/******************************** MAP ********************************/
#>
	partial class UnpackingTest_Combinations_Map
	{
<#
foreach( var __testCase in __mapValues )
{
	foreach( var __expression in __testCase.Item3 )
	{
#>
		[Test]
		public void TestUnpackDictionaryCount_ByteArray_<#= __testCase.Item1 #>_As<#= ToValueId( __expression ) #>_AsIs()
		{
			var result = Unpacking.UnpackDictionaryCount( <#= __expression #> );
			Assert.AreEqual( <#= GetHeaderLength( __expression ) #>, result.ReadCount );
			Assert.AreEqual( <#= __testCase.Item2 #>, result.Value );
		}

		[Test]
		public void TestUnpackDictionaryCount_Stream_<#= __testCase.Item1 #>_As<#= ToValueId( __expression ) #>_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __expression #> ) )
			{
				var result = Unpacking.UnpackDictionaryCount( buffer );
				Assert.AreEqual( <#= GetHeaderLength( __expression ) #>, buffer.Position );
				Assert.AreEqual( <#= __testCase.Item2 #>, result );
			}
		}
<#
	}
}
#>

		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, "DictionaryCount" ) #>

		[Test]
		public void TestUnpackDictionaryCount_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			var result = Unpacking.UnpackDictionaryCount( new byte[]{ 0xFF, 0x80, 0xFF }, 1 );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( 0, result.Value );
		}
	}

<#

/******************************** BINARY ********************************/
#>
	partial class UnpackingTest_Combinations_Raw
	{
<#
foreach( var __testCase in __binaryValues )
{
	foreach( var __expression in __testCase.Item3 )
	{
#>
		[Test]
		public void TestUnpackBinary_ByteArray_<#= __testCase.Item1 #>_As<#= ToValueId( __expression ) #>_AsIs()
		{
			var result = Unpacking.UnpackBinary( <#= __expression #> );
			Assert.AreEqual( <#= __expression.Count( c => c == ',' ) + 1 #>, result.ReadCount );
			Assert.AreEqual( <#= __testCase.Item2 #>, result.Value.Length );
			Assert.That( result.Value, Is.All.EqualTo( 0xFF ) );
		}

		[Test]
		public void TestUnpackBinary_Stream_<#= __testCase.Item1 #>_As<#= ToValueId( __expression ) #>_AsIs()
		{
			using( var buffer = new MemoryStream( <#= __expression #> ) )
			{
				var result = Unpacking.UnpackBinary( buffer );
				Assert.AreEqual( <#= __expression.Count( c => c == ',' ) + 1 #>, buffer.Position );
				Assert.AreEqual( <#= __testCase.Item2 #>, result.Length );
				Assert.That( result, Is.All.EqualTo( 0xFF ) );
			}
		}
		
<#
	}
}
#>
		<#= String.Format( CultureInfo.InvariantCulture, __argumentErrorTemplate, "Binary" ) #>

		[Test]
		public void TestUnpackBinary_ByteArray_Offset_OffsetIsValid_OffsetIsRespected()
		{
			var result = Unpacking.UnpackBinary( new byte[]{ 0xFF, 0xA0, 0xFF }, 1 );
			Assert.AreEqual( 1, result.ReadCount );
			Assert.AreEqual( 0, result.Value.Length );
		}
	}
}
<#+
		
/******************************** HELPERS ********************************/
private static readonly Regex __typeCodePattern =
	new Regex( 
		@"^new\s+byte\s*\[\s*\]\s*\{\s*0x(?<Code>[0-9A-Fa-f]{1,2})",
		RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture
	);

private static string MakeErrorCases( string template, string targetMethod, string currentCase, string expression )
{
	return String.Format( CultureInfo.InvariantCulture, template, targetMethod, currentCase, expression );
}

private static string ToValueId( string expression )
{
	var code =  __typeCodePattern.Match( expression ).Groups[ "Code" ];
	if( !code.Success )
	{
		throw new FormatException( "Unexpected expression :" + expression );
	}
	
	int codeValue;
	if(!Int32.TryParse( code.Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out codeValue ) )
	{
		throw new FormatException( "Unexpected value :" + code.Value );
	}
	
	if( codeValue < 0x80 )
	{
		return "PositiveFixNum" + codeValue;
	}
	else if( 0xe0 <= codeValue )
	{
		return "NegativeFixNumMinus" + Math.Abs( ( sbyte )codeValue );
	}
	else if( 0xCC <= codeValue && codeValue <= 0xCF )
	{
		return "UInt" + ( 8 * Math.Pow( 2, ( codeValue - 0xCC ) ) );
	}
	else if( 0xD0 <= codeValue && codeValue <= 0xD3 )
	{
		return "Int" + ( 8 * Math.Pow( 2, ( codeValue - 0xD0 ) ) );
	}
	else if( codeValue < 0x90 )
	{
		return "FixMap" + ( codeValue -0x80 );
	}
	else if( codeValue < 0xA0 )
	{
		return "FixArray" + ( codeValue -0x90 );
	}
	else if( codeValue < 0xC0 )
	{
		return "FixRaw" + ( codeValue -0xA0 );
	}
	else
	{
		switch( codeValue )
		{
			case 0xDA:
			{
				return "Raw16";
			}
			case 0xDB:
			{
				return "Raw32";
			}
			case 0xDC:
			{
				return "Array16";
			}
			case 0xDD:
			{
				return "Array32";
			}
			case 0xDE:
			{
				return "Map16";
			}
			case 0xDF:
			{
				return "Map32";
			}
			default:
			{
				return "UNNOWN_CODE_" + code.Value;
			}
		}
	}
}

private static int GetHeaderLength( string expression )
{
	var code =  __typeCodePattern.Match( expression ).Groups[ "Code" ];
	if( !code.Success )
	{
		throw new FormatException( "Unexpected expression :" + expression );
	}
	
	int codeValue;
	if(!Int32.TryParse( code.Value, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out codeValue ) )
	{
		throw new FormatException( "Unexpected value :" + code.Value );
	}
	
	if( codeValue < 0x80 )
	{
		return 1;
	}
	else if( 0xe0 <= codeValue )
	{
		return 1;
	}
	else if( 0xCC <= codeValue && codeValue <= 0xCF )
	{
		return 1 + ( codeValue - 0xCB );
	}
	else if( 0xD0 <= codeValue && codeValue <= 0xD3 )
	{
		return 1 + ( codeValue - 0xCF );
	}
	else if( codeValue < 0xB0 )
	{
		return 1;
	}
	else
	{
		switch( codeValue )
		{
			case 0xDA:
			case 0xDC:
			case 0xDE:
			{
				return 1 + 2;
			}
			case 0xDB:
			case 0xDD:
			case 0xDF:
			{
				return 1 + 4;
			}
			default:
			{
				return 1;
			}
		}
	}
}

private static readonly Regex _formatSpecifierPattern =
	new Regex(
		@"[\{\}]",
		RegexOptions.Compiled | RegexOptions.CultureInvariant
	);

private static string EscapeFormatString( string format )
{
	return _formatSpecifierPattern.Replace( format, "$&$&" );
}

private sealed class TestCase
{
	public string[] Expressions;
	public BigInteger Value;
}
#>